(function () {
  "use strict";

  (self["webpackChunkregobs4"] = self["webpackChunkregobs4"] || []).push([["node_modules_pouchdb-adapter-idb_lib_index_es_js"], {
    /***/
    5508: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony import */


      var pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! pouchdb-adapter-utils */
      53875);
      /* harmony import */


      var pouchdb_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! pouchdb-json */
      14477);
      /* harmony import */


      var pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! pouchdb-merge */
      29070);
      /* harmony import */


      var pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! pouchdb-binary-utils */
      84847);
      /* harmony import */


      var pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! pouchdb-errors */
      44090);
      /* harmony import */


      var pouchdb_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! pouchdb-collections */
      31793);
      /* harmony import */


      var pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! pouchdb-utils */
      94084); // IndexedDB requires a versioned database structure, so we use the
      // version here to manage migrations.


      var ADAPTER_VERSION = 5; // The object stores created for each database
      // DOC_STORE stores the document meta data, its revision history and state
      // Keyed by document id

      var DOC_STORE = 'document-store'; // BY_SEQ_STORE stores a particular version of a document, keyed by its
      // sequence id

      var BY_SEQ_STORE = 'by-sequence'; // Where we store attachments

      var ATTACH_STORE = 'attach-store'; // Where we store many-to-many relations
      // between attachment digests and seqs

      var ATTACH_AND_SEQ_STORE = 'attach-seq-store'; // Where we store database-wide meta data in a single record
      // keyed by id: META_STORE

      var META_STORE = 'meta-store'; // Where we store local documents

      var LOCAL_STORE = 'local-store'; // Where we detect blob support

      var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';

      function idbError(callback) {
        return function (evt) {
          var message = 'unknown_error';

          if (evt.target && evt.target.error) {
            message = evt.target.error.name || evt.target.error.message;
          }

          callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.IDB_ERROR, message, evt.type));
        };
      } // Unfortunately, the metadata has to be stringified
      // when it is put into the database, because otherwise
      // IndexedDB can throw errors for deeply-nested objects.
      // Originally we just used JSON.parse/JSON.stringify; now
      // we use this custom vuvuzela library that avoids recursion.
      // If we could do it all over again, we'd probably use a
      // format for the revision trees other than JSON.


      function encodeMetadata(metadata, winningRev$$1, deleted) {
        return {
          data: (0, pouchdb_json__WEBPACK_IMPORTED_MODULE_1__.safeJsonStringify)(metadata),
          winningRev: winningRev$$1,
          deletedOrLocal: deleted ? '1' : '0',
          seq: metadata.seq,
          // highest seq for this doc
          id: metadata.id
        };
      }

      function decodeMetadata(storedObject) {
        if (!storedObject) {
          return null;
        }

        var metadata = (0, pouchdb_json__WEBPACK_IMPORTED_MODULE_1__.safeJsonParse)(storedObject.data);
        metadata.winningRev = storedObject.winningRev;
        metadata.deleted = storedObject.deletedOrLocal === '1';
        metadata.seq = storedObject.seq;
        return metadata;
      } // read the doc back out from the database. we don't store the
      // _id or _rev because we already have _doc_id_rev.


      function decodeDoc(doc) {
        if (!doc) {
          return doc;
        }

        var idx = doc._doc_id_rev.lastIndexOf(':');

        doc._id = doc._doc_id_rev.substring(0, idx - 1);
        doc._rev = doc._doc_id_rev.substring(idx + 1);
        delete doc._doc_id_rev;
        return doc;
      } // Read a blob from the database, encoding as necessary
      // and translating from base64 if the IDB doesn't support
      // native Blobs


      function readBlobData(body, type, asBlob, callback) {
        if (asBlob) {
          if (!body) {
            callback((0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_3__.blob)([''], {
              type: type
            }));
          } else if (typeof body !== 'string') {
            // we have blob support
            callback(body);
          } else {
            // no blob support
            callback((0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_3__.base64StringToBlobOrBuffer)(body, type));
          }
        } else {
          // as base64 string
          if (!body) {
            callback('');
          } else if (typeof body !== 'string') {
            // we have blob support
            (0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_3__.readAsBinaryString)(body, function (binary) {
              callback((0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_3__.btoa)(binary));
            });
          } else {
            // no blob support
            callback(body);
          }
        }
      }

      function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
        var attachments = Object.keys(doc._attachments || {});

        if (!attachments.length) {
          return cb && cb();
        }

        var numDone = 0;

        function checkDone() {
          if (++numDone === attachments.length && cb) {
            cb();
          }
        }

        function fetchAttachment(doc, att) {
          var attObj = doc._attachments[att];
          var digest = attObj.digest;
          var req = txn.objectStore(ATTACH_STORE).get(digest);

          req.onsuccess = function (e) {
            attObj.body = e.target.result.body;
            checkDone();
          };
        }

        attachments.forEach(function (att) {
          if (opts.attachments && opts.include_docs) {
            fetchAttachment(doc, att);
          } else {
            doc._attachments[att].stub = true;
            checkDone();
          }
        });
      } // IDB-specific postprocessing necessary because
      // we don't know whether we stored a true Blob or
      // a base64-encoded string, and if it's a Blob it
      // needs to be read outside of the transaction context


      function postProcessAttachments(results, asBlob) {
        return Promise.all(results.map(function (row) {
          if (row.doc && row.doc._attachments) {
            var attNames = Object.keys(row.doc._attachments);
            return Promise.all(attNames.map(function (att) {
              var attObj = row.doc._attachments[att];

              if (!('body' in attObj)) {
                // already processed
                return;
              }

              var body = attObj.body;
              var type = attObj.content_type;
              return new Promise(function (resolve) {
                readBlobData(body, type, asBlob, function (data) {
                  row.doc._attachments[att] = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.assign)((0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.pick)(attObj, ['digest', 'content_type']), {
                    data: data
                  });
                  resolve();
                });
              });
            }));
          }
        }));
      }

      function compactRevs(revs, docId, txn) {
        var possiblyOrphanedDigests = [];
        var seqStore = txn.objectStore(BY_SEQ_STORE);
        var attStore = txn.objectStore(ATTACH_STORE);
        var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
        var count = revs.length;

        function checkDone() {
          count--;

          if (!count) {
            // done processing all revs
            deleteOrphanedAttachments();
          }
        }

        function deleteOrphanedAttachments() {
          if (!possiblyOrphanedDigests.length) {
            return;
          }

          possiblyOrphanedDigests.forEach(function (digest) {
            var countReq = attAndSeqStore.index('digestSeq').count(IDBKeyRange.bound(digest + '::', digest + "::\uFFFF", false, false));

            countReq.onsuccess = function (e) {
              var count = e.target.result;

              if (!count) {
                // orphaned
                attStore["delete"](digest);
              }
            };
          });
        }

        revs.forEach(function (rev) {
          var index = seqStore.index('_doc_id_rev');
          var key = docId + "::" + rev;

          index.getKey(key).onsuccess = function (e) {
            var seq = e.target.result;

            if (typeof seq !== 'number') {
              return checkDone();
            }

            seqStore["delete"](seq);
            var cursor = attAndSeqStore.index('seq').openCursor(IDBKeyRange.only(seq));

            cursor.onsuccess = function (event) {
              var cursor = event.target.result;

              if (cursor) {
                var digest = cursor.value.digestSeq.split('::')[0];
                possiblyOrphanedDigests.push(digest);
                attAndSeqStore["delete"](cursor.primaryKey);
                cursor["continue"]();
              } else {
                // done
                checkDone();
              }
            };
          };
        });
      }

      function openTransactionSafely(idb, stores, mode) {
        try {
          return {
            txn: idb.transaction(stores, mode)
          };
        } catch (err) {
          return {
            error: err
          };
        }
      }

      var changesHandler$1 = new pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.changesHandler();

      function idbBulkDocs(dbOpts, req, opts, api, idb, callback) {
        var docInfos = req.docs;
        var txn;
        var docStore;
        var bySeqStore;
        var attachStore;
        var attachAndSeqStore;
        var metaStore;
        var docInfoError;
        var metaDoc;

        for (var i = 0, len = docInfos.length; i < len; i++) {
          var doc = docInfos[i];

          if (doc._id && (0, pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_0__.isLocalId)(doc._id)) {
            continue;
          }

          doc = docInfos[i] = (0, pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_0__.parseDoc)(doc, opts.new_edits, dbOpts);

          if (doc.error && !docInfoError) {
            docInfoError = doc;
          }
        }

        if (docInfoError) {
          return callback(docInfoError);
        }

        var allDocsProcessed = false;
        var docCountDelta = 0;
        var results = new Array(docInfos.length);
        var fetchedDocs = new pouchdb_collections__WEBPACK_IMPORTED_MODULE_5__.Map();
        var preconditionErrored = false;
        var blobType = api._meta.blobSupport ? 'blob' : 'base64';
        (0, pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_0__.preprocessAttachments)(docInfos, blobType, function (err) {
          if (err) {
            return callback(err);
          }

          startTransaction();
        });

        function startTransaction() {
          var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, LOCAL_STORE, ATTACH_AND_SEQ_STORE, META_STORE];
          var txnResult = openTransactionSafely(idb, stores, 'readwrite');

          if (txnResult.error) {
            return callback(txnResult.error);
          }

          txn = txnResult.txn;
          txn.onabort = idbError(callback);
          txn.ontimeout = idbError(callback);
          txn.oncomplete = complete;
          docStore = txn.objectStore(DOC_STORE);
          bySeqStore = txn.objectStore(BY_SEQ_STORE);
          attachStore = txn.objectStore(ATTACH_STORE);
          attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
          metaStore = txn.objectStore(META_STORE);

          metaStore.get(META_STORE).onsuccess = function (e) {
            metaDoc = e.target.result;
            updateDocCountIfReady();
          };

          verifyAttachments(function (err) {
            if (err) {
              preconditionErrored = true;
              return callback(err);
            }

            fetchExistingDocs();
          });
        }

        function onAllDocsProcessed() {
          allDocsProcessed = true;
          updateDocCountIfReady();
        }

        function idbProcessDocs() {
          (0, pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_0__.processDocs)(dbOpts.revs_limit, docInfos, api, fetchedDocs, txn, results, writeDoc, opts, onAllDocsProcessed);
        }

        function updateDocCountIfReady() {
          if (!metaDoc || !allDocsProcessed) {
            return;
          } // caching the docCount saves a lot of time in allDocs() and
          // info(), which is why we go to all the trouble of doing this


          metaDoc.docCount += docCountDelta;
          metaStore.put(metaDoc);
        }

        function fetchExistingDocs() {
          if (!docInfos.length) {
            return;
          }

          var numFetched = 0;

          function checkDone() {
            if (++numFetched === docInfos.length) {
              idbProcessDocs();
            }
          }

          function readMetadata(event) {
            var metadata = decodeMetadata(event.target.result);

            if (metadata) {
              fetchedDocs.set(metadata.id, metadata);
            }

            checkDone();
          }

          for (var i = 0, len = docInfos.length; i < len; i++) {
            var docInfo = docInfos[i];

            if (docInfo._id && (0, pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_0__.isLocalId)(docInfo._id)) {
              checkDone(); // skip local docs

              continue;
            }

            var req = docStore.get(docInfo.metadata.id);
            req.onsuccess = readMetadata;
          }
        }

        function complete() {
          if (preconditionErrored) {
            return;
          }

          changesHandler$1.notify(api._meta.name);
          callback(null, results);
        }

        function verifyAttachment(digest, callback) {
          var req = attachStore.get(digest);

          req.onsuccess = function (e) {
            if (!e.target.result) {
              var err = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_STUB, 'unknown stub attachment with digest ' + digest);
              err.status = 412;
              callback(err);
            } else {
              callback();
            }
          };
        }

        function verifyAttachments(finish) {
          var digests = [];
          docInfos.forEach(function (docInfo) {
            if (docInfo.data && docInfo.data._attachments) {
              Object.keys(docInfo.data._attachments).forEach(function (filename) {
                var att = docInfo.data._attachments[filename];

                if (att.stub) {
                  digests.push(att.digest);
                }
              });
            }
          });

          if (!digests.length) {
            return finish();
          }

          var numDone = 0;
          var err;

          function checkDone() {
            if (++numDone === digests.length) {
              finish(err);
            }
          }

          digests.forEach(function (digest) {
            verifyAttachment(digest, function (attErr) {
              if (attErr && !err) {
                err = attErr;
              }

              checkDone();
            });
          });
        }

        function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, isUpdate, delta, resultsIdx, callback) {
          docInfo.metadata.winningRev = winningRev$$1;
          docInfo.metadata.deleted = winningRevIsDeleted;
          var doc = docInfo.data;
          doc._id = docInfo.metadata.id;
          doc._rev = docInfo.metadata.rev;

          if (newRevIsDeleted) {
            doc._deleted = true;
          }

          var hasAttachments = doc._attachments && Object.keys(doc._attachments).length;

          if (hasAttachments) {
            return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);
          }

          docCountDelta += delta;
          updateDocCountIfReady();
          finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);
        }

        function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {
          var doc = docInfo.data;
          var metadata = docInfo.metadata;
          doc._doc_id_rev = metadata.id + '::' + metadata.rev;
          delete doc._id;
          delete doc._rev;

          function afterPutDoc(e) {
            var revsToDelete = docInfo.stemmedRevs || [];

            if (isUpdate && api.auto_compaction) {
              revsToDelete = revsToDelete.concat((0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.compactTree)(docInfo.metadata));
            }

            if (revsToDelete && revsToDelete.length) {
              compactRevs(revsToDelete, docInfo.metadata.id, txn);
            }

            metadata.seq = e.target.result; // Current _rev is calculated from _rev_tree on read
            // delete metadata.rev;

            var metadataToStore = encodeMetadata(metadata, winningRev$$1, winningRevIsDeleted);
            var metaDataReq = docStore.put(metadataToStore);
            metaDataReq.onsuccess = afterPutMetadata;
          }

          function afterPutDocError(e) {
            // ConstraintError, need to update, not put (see #1638 for details)
            e.preventDefault(); // avoid transaction abort

            e.stopPropagation(); // avoid transaction onerror

            var index = bySeqStore.index('_doc_id_rev');
            var getKeyReq = index.getKey(doc._doc_id_rev);

            getKeyReq.onsuccess = function (e) {
              var putReq = bySeqStore.put(doc, e.target.result);
              putReq.onsuccess = afterPutDoc;
            };
          }

          function afterPutMetadata() {
            results[resultsIdx] = {
              ok: true,
              id: metadata.id,
              rev: metadata.rev
            };
            fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
            insertAttachmentMappings(docInfo, metadata.seq, callback);
          }

          var putReq = bySeqStore.put(doc);
          putReq.onsuccess = afterPutDoc;
          putReq.onerror = afterPutDocError;
        }

        function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {
          var doc = docInfo.data;
          var numDone = 0;
          var attachments = Object.keys(doc._attachments);

          function collectResults() {
            if (numDone === attachments.length) {
              finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);
            }
          }

          function attachmentSaved() {
            numDone++;
            collectResults();
          }

          attachments.forEach(function (key) {
            var att = docInfo.data._attachments[key];

            if (!att.stub) {
              var data = att.data;
              delete att.data;
              att.revpos = parseInt(winningRev$$1, 10);
              var digest = att.digest;
              saveAttachment(digest, data, attachmentSaved);
            } else {
              numDone++;
              collectResults();
            }
          });
        } // map seqs to attachment digests, which
        // we will need later during compaction


        function insertAttachmentMappings(docInfo, seq, callback) {
          var attsAdded = 0;
          var attsToAdd = Object.keys(docInfo.data._attachments || {});

          if (!attsToAdd.length) {
            return callback();
          }

          function checkDone() {
            if (++attsAdded === attsToAdd.length) {
              callback();
            }
          }

          function add(att) {
            var digest = docInfo.data._attachments[att].digest;
            var req = attachAndSeqStore.put({
              seq: seq,
              digestSeq: digest + '::' + seq
            });
            req.onsuccess = checkDone;

            req.onerror = function (e) {
              // this callback is for a constaint error, which we ignore
              // because this docid/rev has already been associated with
              // the digest (e.g. when new_edits == false)
              e.preventDefault(); // avoid transaction abort

              e.stopPropagation(); // avoid transaction onerror

              checkDone();
            };
          }

          for (var i = 0; i < attsToAdd.length; i++) {
            add(attsToAdd[i]); // do in parallel
          }
        }

        function saveAttachment(digest, data, callback) {
          var getKeyReq = attachStore.count(digest);

          getKeyReq.onsuccess = function (e) {
            var count = e.target.result;

            if (count) {
              return callback(); // already exists
            }

            var newAtt = {
              digest: digest,
              body: data
            };
            var putReq = attachStore.put(newAtt);
            putReq.onsuccess = callback;
          };
        }
      } // Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations
      // while falling back to a normal IDBCursor operation on browsers that don't support getAll() or
      // getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because
      // we're not processing each document one-at-a-time.


      function runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {
        if (batchSize === -1) {
          batchSize = 1000;
        } // Bail out of getAll()/getAllKeys() in the following cases:
        // 1) either method is unsupported - we need both
        // 2) batchSize is 1 (might as well use IDBCursor)
        // 3) descending – no real way to do this via getAll()/getAllKeys()


        var useGetAll = typeof objectStore.getAll === 'function' && typeof objectStore.getAllKeys === 'function' && batchSize > 1 && !descending;
        var keysBatch;
        var valuesBatch;
        var pseudoCursor;

        function onGetAll(e) {
          valuesBatch = e.target.result;

          if (keysBatch) {
            onBatch(keysBatch, valuesBatch, pseudoCursor);
          }
        }

        function onGetAllKeys(e) {
          keysBatch = e.target.result;

          if (valuesBatch) {
            onBatch(keysBatch, valuesBatch, pseudoCursor);
          }
        }

        function continuePseudoCursor() {
          if (!keysBatch.length) {
            // no more results
            return onBatch();
          } // fetch next batch, exclusive start


          var lastKey = keysBatch[keysBatch.length - 1];
          var newKeyRange;

          if (keyRange && keyRange.upper) {
            try {
              newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper, true, keyRange.upperOpen);
            } catch (e) {
              if (e.name === "DataError" && e.code === 0) {
                return onBatch(); // we're done, startkey and endkey are equal
              }
            }
          } else {
            newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
          }

          keyRange = newKeyRange;
          keysBatch = null;
          valuesBatch = null;
          objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
          objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
        }

        function onCursor(e) {
          var cursor = e.target.result;

          if (!cursor) {
            // done
            return onBatch();
          } // regular IDBCursor acts like a batch where batch size is always 1


          onBatch([cursor.key], [cursor.value], cursor);
        }

        if (useGetAll) {
          pseudoCursor = {
            "continue": continuePseudoCursor
          };
          objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
          objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
        } else if (descending) {
          objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
        } else {
          objectStore.openCursor(keyRange).onsuccess = onCursor;
        }
      } // simple shim for objectStore.getAll(), falling back to IDBCursor


      function getAll(objectStore, keyRange, onSuccess) {
        if (typeof objectStore.getAll === 'function') {
          // use native getAll
          objectStore.getAll(keyRange).onsuccess = onSuccess;
          return;
        } // fall back to cursors


        var values = [];

        function onCursor(e) {
          var cursor = e.target.result;

          if (cursor) {
            values.push(cursor.value);
            cursor["continue"]();
          } else {
            onSuccess({
              target: {
                result: values
              }
            });
          }
        }

        objectStore.openCursor(keyRange).onsuccess = onCursor;
      }

      function allDocsKeys(keys, docStore, onBatch) {
        // It's not guaranted to be returned in right order  
        var valuesBatch = new Array(keys.length);
        var count = 0;
        keys.forEach(function (key, index) {
          docStore.get(key).onsuccess = function (event) {
            if (event.target.result) {
              valuesBatch[index] = event.target.result;
            } else {
              valuesBatch[index] = {
                key: key,
                error: 'not_found'
              };
            }

            count++;

            if (count === keys.length) {
              onBatch(keys, valuesBatch, {});
            }
          };
        });
      }

      function createKeyRange(start, end, inclusiveEnd, key, descending) {
        try {
          if (start && end) {
            if (descending) {
              return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
            } else {
              return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
            }
          } else if (start) {
            if (descending) {
              return IDBKeyRange.upperBound(start);
            } else {
              return IDBKeyRange.lowerBound(start);
            }
          } else if (end) {
            if (descending) {
              return IDBKeyRange.lowerBound(end, !inclusiveEnd);
            } else {
              return IDBKeyRange.upperBound(end, !inclusiveEnd);
            }
          } else if (key) {
            return IDBKeyRange.only(key);
          }
        } catch (e) {
          return {
            error: e
          };
        }

        return null;
      }

      function idbAllDocs(opts, idb, callback) {
        var start = 'startkey' in opts ? opts.startkey : false;
        var end = 'endkey' in opts ? opts.endkey : false;
        var key = 'key' in opts ? opts.key : false;
        var keys = 'keys' in opts ? opts.keys : false;
        var skip = opts.skip || 0;
        var limit = typeof opts.limit === 'number' ? opts.limit : -1;
        var inclusiveEnd = opts.inclusive_end !== false;
        var keyRange;
        var keyRangeError;

        if (!keys) {
          keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);
          keyRangeError = keyRange && keyRange.error;

          if (keyRangeError && !(keyRangeError.name === "DataError" && keyRangeError.code === 0)) {
            // DataError with error code 0 indicates start is less than end, so
            // can just do an empty query. Else need to throw
            return callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.IDB_ERROR, keyRangeError.name, keyRangeError.message));
          }
        }

        var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];

        if (opts.attachments) {
          stores.push(ATTACH_STORE);
        }

        var txnResult = openTransactionSafely(idb, stores, 'readonly');

        if (txnResult.error) {
          return callback(txnResult.error);
        }

        var txn = txnResult.txn;
        txn.oncomplete = onTxnComplete;
        txn.onabort = idbError(callback);
        var docStore = txn.objectStore(DOC_STORE);
        var seqStore = txn.objectStore(BY_SEQ_STORE);
        var metaStore = txn.objectStore(META_STORE);
        var docIdRevIndex = seqStore.index('_doc_id_rev');
        var results = [];
        var docCount;
        var updateSeq;

        metaStore.get(META_STORE).onsuccess = function (e) {
          docCount = e.target.result.docCount;
        };
        /* istanbul ignore if */


        if (opts.update_seq) {
          getMaxUpdateSeq(seqStore, function (e) {
            if (e.target.result && e.target.result.length > 0) {
              updateSeq = e.target.result[0];
            }
          });
        }

        function getMaxUpdateSeq(objectStore, onSuccess) {
          function onCursor(e) {
            var cursor = e.target.result;
            var maxKey = undefined;

            if (cursor && cursor.key) {
              maxKey = cursor.key;
            }

            return onSuccess({
              target: {
                result: [maxKey]
              }
            });
          }

          objectStore.openCursor(null, 'prev').onsuccess = onCursor;
        } // if the user specifies include_docs=true, then we don't
        // want to block the main cursor while we're fetching the doc


        function fetchDocAsynchronously(metadata, row, winningRev$$1) {
          var key = metadata.id + "::" + winningRev$$1;

          docIdRevIndex.get(key).onsuccess = function onGetDoc(e) {
            row.doc = decodeDoc(e.target.result) || {};

            if (opts.conflicts) {
              var conflicts = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.collectConflicts)(metadata);

              if (conflicts.length) {
                row.doc._conflicts = conflicts;
              }
            }

            fetchAttachmentsIfNecessary(row.doc, opts, txn);
          };
        }

        function allDocsInner(winningRev$$1, metadata) {
          var row = {
            id: metadata.id,
            key: metadata.id,
            value: {
              rev: winningRev$$1
            }
          };
          var deleted = metadata.deleted;

          if (deleted) {
            if (keys) {
              results.push(row); // deleted docs are okay with "keys" requests

              row.value.deleted = true;
              row.doc = null;
            }
          } else if (skip-- <= 0) {
            results.push(row);

            if (opts.include_docs) {
              fetchDocAsynchronously(metadata, row, winningRev$$1);
            }
          }
        }

        function processBatch(batchValues) {
          for (var i = 0, len = batchValues.length; i < len; i++) {
            if (results.length === limit) {
              break;
            }

            var batchValue = batchValues[i];

            if (batchValue.error && keys) {
              // key was not found with "keys" requests
              results.push(batchValue);
              continue;
            }

            var metadata = decodeMetadata(batchValue);
            var winningRev$$1 = metadata.winningRev;
            allDocsInner(winningRev$$1, metadata);
          }
        }

        function onBatch(batchKeys, batchValues, cursor) {
          if (!cursor) {
            return;
          }

          processBatch(batchValues);

          if (results.length < limit) {
            cursor["continue"]();
          }
        }

        function onGetAll(e) {
          var values = e.target.result;

          if (opts.descending) {
            values = values.reverse();
          }

          processBatch(values);
        }

        function onResultsReady() {
          var returnVal = {
            total_rows: docCount,
            offset: opts.skip,
            rows: results
          };
          /* istanbul ignore if */

          if (opts.update_seq && updateSeq !== undefined) {
            returnVal.update_seq = updateSeq;
          }

          callback(null, returnVal);
        }

        function onTxnComplete() {
          if (opts.attachments) {
            postProcessAttachments(results, opts.binary).then(onResultsReady);
          } else {
            onResultsReady();
          }
        } // don't bother doing any requests if start > end or limit === 0


        if (keyRangeError || limit === 0) {
          return;
        }

        if (keys) {
          return allDocsKeys(opts.keys, docStore, onBatch);
        }

        if (limit === -1) {
          // just fetch everything
          return getAll(docStore, keyRange, onGetAll);
        } // else do a cursor
        // choose a batch size based on the skip, since we'll need to skip that many


        runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);
      } //
      // Blobs are not supported in all versions of IndexedDB, notably
      // Chrome <37 and Android <5. In those versions, storing a blob will throw.
      //
      // Various other blob bugs exist in Chrome v37-42 (inclusive).
      // Detecting them is expensive and confusing to users, and Chrome 37-42
      // is at very low usage worldwide, so we do a hacky userAgent check instead.
      //
      // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
      // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
      // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
      //


      function checkBlobSupport(txn) {
        return new Promise(function (resolve) {
          var blob$$1 = (0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_3__.blob)(['']);
          var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');

          req.onsuccess = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//); // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx

            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };

          req.onerror = txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
          };
        })["catch"](function () {
          return false; // error, so assume unsupported
        });
      }

      function countDocs(txn, cb) {
        var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');

        index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
          cb(e.target.result);
        };
      } // This task queue ensures that IDB open calls are done in their own tick


      var running = false;
      var queue = [];

      function tryCode(fun, err, res, PouchDB) {
        try {
          fun(err, res);
        } catch (err) {
          // Shouldn't happen, but in some odd cases
          // IndexedDB implementations might throw a sync
          // error, in which case this will at least log it.
          PouchDB.emit('error', err);
        }
      }

      function applyNext() {
        if (running || !queue.length) {
          return;
        }

        running = true;
        queue.shift()();
      }

      function enqueueTask(action, callback, PouchDB) {
        queue.push(function runAction() {
          action(function runCallback(err, res) {
            tryCode(callback, err, res, PouchDB);
            running = false;
            (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.nextTick)(function runNext() {
              applyNext(PouchDB);
            });
          });
        });
        applyNext();
      }

      function changes(opts, api, dbName, idb) {
        opts = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.clone)(opts);

        if (opts.continuous) {
          var id = dbName + ':' + (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.uuid)();
          changesHandler$1.addListener(dbName, id, api, opts);
          changesHandler$1.notify(dbName);
          return {
            cancel: function cancel() {
              changesHandler$1.removeListener(dbName, id);
            }
          };
        }

        var docIds = opts.doc_ids && new pouchdb_collections__WEBPACK_IMPORTED_MODULE_5__.Set(opts.doc_ids);
        opts.since = opts.since || 0;
        var lastSeq = opts.since;
        var limit = 'limit' in opts ? opts.limit : -1;

        if (limit === 0) {
          limit = 1; // per CouchDB _changes spec
        }

        var results = [];
        var numResults = 0;
        var filter = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.filterChange)(opts);
        var docIdsToMetadata = new pouchdb_collections__WEBPACK_IMPORTED_MODULE_5__.Map();
        var txn;
        var bySeqStore;
        var docStore;
        var docIdRevIndex;

        function onBatch(batchKeys, batchValues, cursor) {
          if (!cursor || !batchKeys.length) {
            // done
            return;
          }

          var winningDocs = new Array(batchKeys.length);
          var metadatas = new Array(batchKeys.length);

          function processMetadataAndWinningDoc(metadata, winningDoc) {
            var change = opts.processChange(winningDoc, metadata, opts);
            lastSeq = change.seq = metadata.seq;
            var filtered = filter(change);

            if (typeof filtered === 'object') {
              // anything but true/false indicates error
              return Promise.reject(filtered);
            }

            if (!filtered) {
              return Promise.resolve();
            }

            numResults++;

            if (opts.return_docs) {
              results.push(change);
            } // process the attachment immediately
            // for the benefit of live listeners


            if (opts.attachments && opts.include_docs) {
              return new Promise(function (resolve) {
                fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
                  postProcessAttachments([change], opts.binary).then(function () {
                    resolve(change);
                  });
                });
              });
            } else {
              return Promise.resolve(change);
            }
          }

          function onBatchDone() {
            var promises = [];

            for (var i = 0, len = winningDocs.length; i < len; i++) {
              if (numResults === limit) {
                break;
              }

              var winningDoc = winningDocs[i];

              if (!winningDoc) {
                continue;
              }

              var metadata = metadatas[i];
              promises.push(processMetadataAndWinningDoc(metadata, winningDoc));
            }

            Promise.all(promises).then(function (changes) {
              for (var i = 0, len = changes.length; i < len; i++) {
                if (changes[i]) {
                  opts.onChange(changes[i]);
                }
              }
            })["catch"](opts.complete);

            if (numResults !== limit) {
              cursor["continue"]();
            }
          } // Fetch all metadatas/winningdocs from this batch in parallel, then process
          // them all only once all data has been collected. This is done in parallel
          // because it's faster than doing it one-at-a-time.


          var numDone = 0;
          batchValues.forEach(function (value, i) {
            var doc = decodeDoc(value);
            var seq = batchKeys[i];
            fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {
              metadatas[i] = metadata;
              winningDocs[i] = winningDoc;

              if (++numDone === batchKeys.length) {
                onBatchDone();
              }
            });
          });
        }

        function onGetMetadata(doc, seq, metadata, cb) {
          if (metadata.seq !== seq) {
            // some other seq is later
            return cb();
          }

          if (metadata.winningRev === doc._rev) {
            // this is the winning doc
            return cb(metadata, doc);
          } // fetch winning doc in separate request


          var docIdRev = doc._id + '::' + metadata.winningRev;
          var req = docIdRevIndex.get(docIdRev);

          req.onsuccess = function (e) {
            cb(metadata, decodeDoc(e.target.result));
          };
        }

        function fetchWinningDocAndMetadata(doc, seq, cb) {
          if (docIds && !docIds.has(doc._id)) {
            return cb();
          }

          var metadata = docIdsToMetadata.get(doc._id);

          if (metadata) {
            // cached
            return onGetMetadata(doc, seq, metadata, cb);
          } // metadata not cached, have to go fetch it


          docStore.get(doc._id).onsuccess = function (e) {
            metadata = decodeMetadata(e.target.result);
            docIdsToMetadata.set(doc._id, metadata);
            onGetMetadata(doc, seq, metadata, cb);
          };
        }

        function finish() {
          opts.complete(null, {
            results: results,
            last_seq: lastSeq
          });
        }

        function onTxnComplete() {
          if (!opts.continuous && opts.attachments) {
            // cannot guarantee that postProcessing was already done,
            // so do it again
            postProcessAttachments(results).then(finish);
          } else {
            finish();
          }
        }

        var objectStores = [DOC_STORE, BY_SEQ_STORE];

        if (opts.attachments) {
          objectStores.push(ATTACH_STORE);
        }

        var txnResult = openTransactionSafely(idb, objectStores, 'readonly');

        if (txnResult.error) {
          return opts.complete(txnResult.error);
        }

        txn = txnResult.txn;
        txn.onabort = idbError(opts.complete);
        txn.oncomplete = onTxnComplete;
        bySeqStore = txn.objectStore(BY_SEQ_STORE);
        docStore = txn.objectStore(DOC_STORE);
        docIdRevIndex = bySeqStore.index('_doc_id_rev');
        var keyRange = opts.since && !opts.descending ? IDBKeyRange.lowerBound(opts.since, true) : null;
        runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);
      }

      var cachedDBs = new pouchdb_collections__WEBPACK_IMPORTED_MODULE_5__.Map();
      var blobSupportPromise;
      var openReqList = new pouchdb_collections__WEBPACK_IMPORTED_MODULE_5__.Map();

      function IdbPouch(opts, callback) {
        var api = this;
        enqueueTask(function (thisCallback) {
          init(api, opts, thisCallback);
        }, callback, api.constructor);
      }

      function init(api, opts, callback) {
        var dbName = opts.name;
        var idb = null;
        api._meta = null; // called when creating a fresh new database

        function createSchema(db) {
          var docStore = db.createObjectStore(DOC_STORE, {
            keyPath: 'id'
          });
          db.createObjectStore(BY_SEQ_STORE, {
            autoIncrement: true
          }).createIndex('_doc_id_rev', '_doc_id_rev', {
            unique: true
          });
          db.createObjectStore(ATTACH_STORE, {
            keyPath: 'digest'
          });
          db.createObjectStore(META_STORE, {
            keyPath: 'id',
            autoIncrement: false
          });
          db.createObjectStore(DETECT_BLOB_SUPPORT_STORE); // added in v2

          docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {
            unique: false
          }); // added in v3

          db.createObjectStore(LOCAL_STORE, {
            keyPath: '_id'
          }); // added in v4

          var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, {
            autoIncrement: true
          });
          attAndSeqStore.createIndex('seq', 'seq');
          attAndSeqStore.createIndex('digestSeq', 'digestSeq', {
            unique: true
          });
        } // migration to version 2
        // unfortunately "deletedOrLocal" is a misnomer now that we no longer
        // store local docs in the main doc-store, but whaddyagonnado


        function addDeletedOrLocalIndex(txn, callback) {
          var docStore = txn.objectStore(DOC_STORE);
          docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {
            unique: false
          });

          docStore.openCursor().onsuccess = function (event) {
            var cursor = event.target.result;

            if (cursor) {
              var metadata = cursor.value;
              var deleted = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.isDeleted)(metadata);
              metadata.deletedOrLocal = deleted ? "1" : "0";
              docStore.put(metadata);
              cursor["continue"]();
            } else {
              callback();
            }
          };
        } // migration to version 3 (part 1)


        function createLocalStoreSchema(db) {
          db.createObjectStore(LOCAL_STORE, {
            keyPath: '_id'
          }).createIndex('_doc_id_rev', '_doc_id_rev', {
            unique: true
          });
        } // migration to version 3 (part 2)


        function migrateLocalStore(txn, cb) {
          var localStore = txn.objectStore(LOCAL_STORE);
          var docStore = txn.objectStore(DOC_STORE);
          var seqStore = txn.objectStore(BY_SEQ_STORE);
          var cursor = docStore.openCursor();

          cursor.onsuccess = function (event) {
            var cursor = event.target.result;

            if (cursor) {
              var metadata = cursor.value;
              var docId = metadata.id;
              var local = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.isLocalId)(docId);
              var rev = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.winningRev)(metadata);

              if (local) {
                var docIdRev = docId + "::" + rev; // remove all seq entries
                // associated with this docId

                var start = docId + "::";
                var end = docId + "::~";
                var index = seqStore.index('_doc_id_rev');
                var range = IDBKeyRange.bound(start, end, false, false);
                var seqCursor = index.openCursor(range);

                seqCursor.onsuccess = function (e) {
                  seqCursor = e.target.result;

                  if (!seqCursor) {
                    // done
                    docStore["delete"](cursor.primaryKey);
                    cursor["continue"]();
                  } else {
                    var data = seqCursor.value;

                    if (data._doc_id_rev === docIdRev) {
                      localStore.put(data);
                    }

                    seqStore["delete"](seqCursor.primaryKey);
                    seqCursor["continue"]();
                  }
                };
              } else {
                cursor["continue"]();
              }
            } else if (cb) {
              cb();
            }
          };
        } // migration to version 4 (part 1)


        function addAttachAndSeqStore(db) {
          var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, {
            autoIncrement: true
          });
          attAndSeqStore.createIndex('seq', 'seq');
          attAndSeqStore.createIndex('digestSeq', 'digestSeq', {
            unique: true
          });
        } // migration to version 4 (part 2)


        function migrateAttsAndSeqs(txn, callback) {
          var seqStore = txn.objectStore(BY_SEQ_STORE);
          var attStore = txn.objectStore(ATTACH_STORE);
          var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE); // need to actually populate the table. this is the expensive part,
          // so as an optimization, check first that this database even
          // contains attachments

          var req = attStore.count();

          req.onsuccess = function (e) {
            var count = e.target.result;

            if (!count) {
              return callback(); // done
            }

            seqStore.openCursor().onsuccess = function (e) {
              var cursor = e.target.result;

              if (!cursor) {
                return callback(); // done
              }

              var doc = cursor.value;
              var seq = cursor.primaryKey;
              var atts = Object.keys(doc._attachments || {});
              var digestMap = {};

              for (var j = 0; j < atts.length; j++) {
                var att = doc._attachments[atts[j]];
                digestMap[att.digest] = true; // uniq digests, just in case
              }

              var digests = Object.keys(digestMap);

              for (j = 0; j < digests.length; j++) {
                var digest = digests[j];
                attAndSeqStore.put({
                  seq: seq,
                  digestSeq: digest + '::' + seq
                });
              }

              cursor["continue"]();
            };
          };
        } // migration to version 5
        // Instead of relying on on-the-fly migration of metadata,
        // this brings the doc-store to its modern form:
        // - metadata.winningrev
        // - metadata.seq
        // - stringify the metadata when storing it


        function migrateMetadata(txn) {
          function decodeMetadataCompat(storedObject) {
            if (!storedObject.data) {
              // old format, when we didn't store it stringified
              storedObject.deleted = storedObject.deletedOrLocal === '1';
              return storedObject;
            }

            return decodeMetadata(storedObject);
          } // ensure that every metadata has a winningRev and seq,
          // which was previously created on-the-fly but better to migrate


          var bySeqStore = txn.objectStore(BY_SEQ_STORE);
          var docStore = txn.objectStore(DOC_STORE);
          var cursor = docStore.openCursor();

          cursor.onsuccess = function (e) {
            var cursor = e.target.result;

            if (!cursor) {
              return; // done
            }

            var metadata = decodeMetadataCompat(cursor.value);
            metadata.winningRev = metadata.winningRev || (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.winningRev)(metadata);

            function fetchMetadataSeq() {
              // metadata.seq was added post-3.2.0, so if it's missing,
              // we need to fetch it manually
              var start = metadata.id + '::';
              var end = metadata.id + "::\uFFFF";
              var req = bySeqStore.index('_doc_id_rev').openCursor(IDBKeyRange.bound(start, end));
              var metadataSeq = 0;

              req.onsuccess = function (e) {
                var cursor = e.target.result;

                if (!cursor) {
                  metadata.seq = metadataSeq;
                  return onGetMetadataSeq();
                }

                var seq = cursor.primaryKey;

                if (seq > metadataSeq) {
                  metadataSeq = seq;
                }

                cursor["continue"]();
              };
            }

            function onGetMetadataSeq() {
              var metadataToStore = encodeMetadata(metadata, metadata.winningRev, metadata.deleted);
              var req = docStore.put(metadataToStore);

              req.onsuccess = function () {
                cursor["continue"]();
              };
            }

            if (metadata.seq) {
              return onGetMetadataSeq();
            }

            fetchMetadataSeq();
          };
        }

        api._remote = false;

        api.type = function () {
          return 'idb';
        };

        api._id = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.toPromise)(function (callback) {
          callback(null, api._meta.instanceId);
        });

        api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
          idbBulkDocs(opts, req, reqOpts, api, idb, callback);
        }; // First we look up the metadata in the ids database, then we fetch the
        // current revision(s) from the by sequence store


        api._get = function idb_get(id, opts, callback) {
          var doc;
          var metadata;
          var err;
          var txn = opts.ctx;

          if (!txn) {
            var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');

            if (txnResult.error) {
              return callback(txnResult.error);
            }

            txn = txnResult.txn;
          }

          function finish() {
            callback(err, {
              doc: doc,
              metadata: metadata,
              ctx: txn
            });
          }

          txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
            metadata = decodeMetadata(e.target.result); // we can determine the result here if:
            // 1. there is no such document
            // 2. the document is deleted and we don't ask about specific rev
            // When we ask with opts.rev we expect the answer to be either
            // doc (possibly with _deleted=true) or missing error

            if (!metadata) {
              err = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC, 'missing');
              return finish();
            }

            var rev;

            if (!opts.rev) {
              rev = metadata.winningRev;
              var deleted = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.isDeleted)(metadata);

              if (deleted) {
                err = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC, "deleted");
                return finish();
              }
            } else {
              rev = opts.latest ? (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.latest)(opts.rev, metadata) : opts.rev;
            }

            var objectStore = txn.objectStore(BY_SEQ_STORE);
            var key = metadata.id + '::' + rev;

            objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
              doc = e.target.result;

              if (doc) {
                doc = decodeDoc(doc);
              }

              if (!doc) {
                err = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC, 'missing');
                return finish();
              }

              finish();
            };
          };
        };

        api._getAttachment = function (docId, attachId, attachment, opts, callback) {
          var txn;

          if (opts.ctx) {
            txn = opts.ctx;
          } else {
            var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');

            if (txnResult.error) {
              return callback(txnResult.error);
            }

            txn = txnResult.txn;
          }

          var digest = attachment.digest;
          var type = attachment.content_type;

          txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
            var body = e.target.result.body;
            readBlobData(body, type, opts.binary, function (blobData) {
              callback(null, blobData);
            });
          };
        };

        api._info = function idb_info(callback) {
          var updateSeq;
          var docCount;
          var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');

          if (txnResult.error) {
            return callback(txnResult.error);
          }

          var txn = txnResult.txn;

          txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
            docCount = e.target.result.docCount;
          };

          txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {
            var cursor = e.target.result;
            updateSeq = cursor ? cursor.key : 0;
          };

          txn.oncomplete = function () {
            callback(null, {
              doc_count: docCount,
              update_seq: updateSeq,
              // for debugging
              idb_attachment_format: api._meta.blobSupport ? 'binary' : 'base64'
            });
          };
        };

        api._allDocs = function idb_allDocs(opts, callback) {
          idbAllDocs(opts, idb, callback);
        };

        api._changes = function idbChanges(opts) {
          return changes(opts, api, dbName, idb);
        };

        api._close = function (callback) {
          // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close
          // "Returns immediately and closes the connection in a separate thread..."
          idb.close();
          cachedDBs["delete"](dbName);
          callback();
        };

        api._getRevisionTree = function (docId, callback) {
          var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');

          if (txnResult.error) {
            return callback(txnResult.error);
          }

          var txn = txnResult.txn;
          var req = txn.objectStore(DOC_STORE).get(docId);

          req.onsuccess = function (event) {
            var doc = decodeMetadata(event.target.result);

            if (!doc) {
              callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC));
            } else {
              callback(null, doc.rev_tree);
            }
          };
        }; // This function removes revisions of document docId
        // which are listed in revs and sets this document
        // revision to to rev_tree


        api._doCompaction = function (docId, revs, callback) {
          var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, ATTACH_AND_SEQ_STORE];
          var txnResult = openTransactionSafely(idb, stores, 'readwrite');

          if (txnResult.error) {
            return callback(txnResult.error);
          }

          var txn = txnResult.txn;
          var docStore = txn.objectStore(DOC_STORE);

          docStore.get(docId).onsuccess = function (event) {
            var metadata = decodeMetadata(event.target.result);
            (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_2__.traverseRevTree)(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {
              var rev = pos + '-' + revHash;

              if (revs.indexOf(rev) !== -1) {
                opts.status = 'missing';
              }
            });
            compactRevs(revs, docId, txn);
            var winningRev$$1 = metadata.winningRev;
            var deleted = metadata.deleted;
            txn.objectStore(DOC_STORE).put(encodeMetadata(metadata, winningRev$$1, deleted));
          };

          txn.onabort = idbError(callback);

          txn.oncomplete = function () {
            callback();
          };
        };

        api._getLocal = function (id, callback) {
          var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');

          if (txnResult.error) {
            return callback(txnResult.error);
          }

          var tx = txnResult.txn;
          var req = tx.objectStore(LOCAL_STORE).get(id);
          req.onerror = idbError(callback);

          req.onsuccess = function (e) {
            var doc = e.target.result;

            if (!doc) {
              callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC));
            } else {
              delete doc['_doc_id_rev']; // for backwards compat

              callback(null, doc);
            }
          };
        };

        api._putLocal = function (doc, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }

          delete doc._revisions; // ignore this, trust the rev

          var oldRev = doc._rev;
          var id = doc._id;

          if (!oldRev) {
            doc._rev = '0-1';
          } else {
            doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
          }

          var tx = opts.ctx;
          var ret;

          if (!tx) {
            var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');

            if (txnResult.error) {
              return callback(txnResult.error);
            }

            tx = txnResult.txn;
            tx.onerror = idbError(callback);

            tx.oncomplete = function () {
              if (ret) {
                callback(null, ret);
              }
            };
          }

          var oStore = tx.objectStore(LOCAL_STORE);
          var req;

          if (oldRev) {
            req = oStore.get(id);

            req.onsuccess = function (e) {
              var oldDoc = e.target.result;

              if (!oldDoc || oldDoc._rev !== oldRev) {
                callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.REV_CONFLICT));
              } else {
                // update
                var req = oStore.put(doc);

                req.onsuccess = function () {
                  ret = {
                    ok: true,
                    id: doc._id,
                    rev: doc._rev
                  };

                  if (opts.ctx) {
                    // return immediately
                    callback(null, ret);
                  }
                };
              }
            };
          } else {
            // new doc
            req = oStore.add(doc);

            req.onerror = function (e) {
              // constraint error, already exists
              callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.REV_CONFLICT));
              e.preventDefault(); // avoid transaction abort

              e.stopPropagation(); // avoid transaction onerror
            };

            req.onsuccess = function () {
              ret = {
                ok: true,
                id: doc._id,
                rev: doc._rev
              };

              if (opts.ctx) {
                // return immediately
                callback(null, ret);
              }
            };
          }
        };

        api._removeLocal = function (doc, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }

          var tx = opts.ctx;

          if (!tx) {
            var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');

            if (txnResult.error) {
              return callback(txnResult.error);
            }

            tx = txnResult.txn;

            tx.oncomplete = function () {
              if (ret) {
                callback(null, ret);
              }
            };
          }

          var ret;
          var id = doc._id;
          var oStore = tx.objectStore(LOCAL_STORE);
          var req = oStore.get(id);
          req.onerror = idbError(callback);

          req.onsuccess = function (e) {
            var oldDoc = e.target.result;

            if (!oldDoc || oldDoc._rev !== doc._rev) {
              callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC));
            } else {
              oStore["delete"](id);
              ret = {
                ok: true,
                id: id,
                rev: '0-0'
              };

              if (opts.ctx) {
                // return immediately
                callback(null, ret);
              }
            }
          };
        };

        api._destroy = function (opts, callback) {
          changesHandler$1.removeAllListeners(dbName); //Close open request for "dbName" database to fix ie delay.

          var openReq = openReqList.get(dbName);

          if (openReq && openReq.result) {
            openReq.result.close();
            cachedDBs["delete"](dbName);
          }

          var req = indexedDB.deleteDatabase(dbName);

          req.onsuccess = function () {
            //Remove open request from the list.
            openReqList["delete"](dbName);

            if ((0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.hasLocalStorage)() && dbName in localStorage) {
              delete localStorage[dbName];
            }

            callback(null, {
              'ok': true
            });
          };

          req.onerror = idbError(callback);
        };

        var cached = cachedDBs.get(dbName);

        if (cached) {
          idb = cached.idb;
          api._meta = cached.global;
          return (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.nextTick)(function () {
            callback(null, api);
          });
        }

        var req = indexedDB.open(dbName, ADAPTER_VERSION);
        openReqList.set(dbName, req);

        req.onupgradeneeded = function (e) {
          var db = e.target.result;

          if (e.oldVersion < 1) {
            return createSchema(db); // new db, initial schema
          } // do migrations


          var txn = e.currentTarget.transaction; // these migrations have to be done in this function, before
          // control is returned to the event loop, because IndexedDB

          if (e.oldVersion < 3) {
            createLocalStoreSchema(db); // v2 -> v3
          }

          if (e.oldVersion < 4) {
            addAttachAndSeqStore(db); // v3 -> v4
          }

          var migrations = [addDeletedOrLocalIndex, // v1 -> v2
          migrateLocalStore, // v2 -> v3
          migrateAttsAndSeqs, // v3 -> v4
          migrateMetadata // v4 -> v5
          ];
          var i = e.oldVersion;

          function next() {
            var migration = migrations[i - 1];
            i++;

            if (migration) {
              migration(txn, next);
            }
          }

          next();
        };

        req.onsuccess = function (e) {
          idb = e.target.result;

          idb.onversionchange = function () {
            idb.close();
            cachedDBs["delete"](dbName);
          };

          idb.onabort = function (e) {
            (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.guardedConsole)('error', 'Database has a global failure', e.target.error);
            idb.close();
            cachedDBs["delete"](dbName);
          }; // Do a few setup operations (in parallel as much as possible):
          // 1. Fetch meta doc
          // 2. Check blob support
          // 3. Calculate docCount
          // 4. Generate an instanceId if necessary
          // 5. Store docCount and instanceId on meta doc


          var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE, DOC_STORE], 'readwrite');
          var storedMetaDoc = false;
          var metaDoc;
          var docCount;
          var blobSupport;
          var instanceId;

          function completeSetup() {
            if (typeof blobSupport === 'undefined' || !storedMetaDoc) {
              return;
            }

            api._meta = {
              name: dbName,
              instanceId: instanceId,
              blobSupport: blobSupport
            };
            cachedDBs.set(dbName, {
              idb: idb,
              global: api._meta
            });
            callback(null, api);
          }

          function storeMetaDocIfReady() {
            if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {
              return;
            }

            var instanceKey = dbName + '_id';

            if (instanceKey in metaDoc) {
              instanceId = metaDoc[instanceKey];
            } else {
              metaDoc[instanceKey] = instanceId = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.uuid)();
            }

            metaDoc.docCount = docCount;
            txn.objectStore(META_STORE).put(metaDoc);
          } //
          // fetch or generate the instanceId
          //


          txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
            metaDoc = e.target.result || {
              id: META_STORE
            };
            storeMetaDocIfReady();
          }; //
          // countDocs
          //


          countDocs(txn, function (count) {
            docCount = count;
            storeMetaDocIfReady();
          }); //
          // check blob support
          //

          if (!blobSupportPromise) {
            // make sure blob support is only checked once
            blobSupportPromise = checkBlobSupport(txn);
          }

          blobSupportPromise.then(function (val) {
            blobSupport = val;
            completeSetup();
          }); // only when the metadata put transaction has completed,
          // consider the setup done

          txn.oncomplete = function () {
            storedMetaDoc = true;
            completeSetup();
          };

          txn.onabort = idbError(callback);
        };

        req.onerror = function (e) {
          var msg = e.target.error && e.target.error.message;

          if (!msg) {
            msg = 'Failed to open indexedDB, are you in private browsing mode?';
          } else if (msg.indexOf("stored database is a higher version") !== -1) {
            msg = new Error('This DB was created with the newer "indexeddb" adapter, but you are trying to open it with the older "idb" adapter');
          }

          (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_6__.guardedConsole)('error', msg);
          callback((0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.IDB_ERROR, msg));
        };
      }

      IdbPouch.valid = function () {
        // Following #7085 buggy idb versions (typically Safari < 10.1) are
        // considered valid.
        // On Firefox SecurityError is thrown while referencing indexedDB if cookies
        // are not allowed. `typeof indexedDB` also triggers the error.
        try {
          // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
        } catch (e) {
          return false;
        }
      };

      function index(PouchDB) {
        PouchDB.adapter('idb', IdbPouch, true);
      }
      /* harmony default export */


      __webpack_exports__["default"] = index;
      /***/
    },

    /***/
    53875: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "invalidIdError": function invalidIdError() {
          return (
            /* reexport safe */
            pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__.invalidIdError
          );
        },

        /* harmony export */
        "normalizeDdocFunctionName": function normalizeDdocFunctionName() {
          return (
            /* reexport safe */
            pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__.normalizeDdocFunctionName
          );
        },

        /* harmony export */
        "parseDdocFunctionName": function parseDdocFunctionName() {
          return (
            /* reexport safe */
            pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__.parseDdocFunctionName
          );
        },

        /* harmony export */
        "isDeleted": function isDeleted() {
          return (
            /* reexport safe */
            pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isDeleted
          );
        },

        /* harmony export */
        "isLocalId": function isLocalId() {
          return (
            /* reexport safe */
            pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isLocalId
          );
        },

        /* harmony export */
        "allDocsKeysQuery": function allDocsKeysQuery() {
          return (
            /* binding */
            _allDocsKeysQuery
          );
        },

        /* harmony export */
        "parseDoc": function parseDoc() {
          return (
            /* binding */
            _parseDoc
          );
        },

        /* harmony export */
        "preprocessAttachments": function preprocessAttachments() {
          return (
            /* binding */
            _preprocessAttachments
          );
        },

        /* harmony export */
        "processDocs": function processDocs() {
          return (
            /* binding */
            _processDocs
          );
        },

        /* harmony export */
        "updateDoc": function updateDoc() {
          return (
            /* binding */
            _updateDoc
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! pouchdb-utils */
      94084);
      /* harmony import */


      var pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! pouchdb-binary-utils */
      84847);
      /* harmony import */


      var pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! pouchdb-md5 */
      80733);
      /* harmony import */


      var pouchdb_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! pouchdb-collections */
      31793);
      /* harmony import */


      var pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! pouchdb-errors */
      44090);
      /* harmony import */


      var pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! pouchdb-merge */
      29070);

      function _allDocsKeysQuery(api, opts) {
        var keys = opts.keys;
        var finalResults = {
          offset: opts.skip
        };
        return Promise.all(keys.map(function (key) {
          var subOpts = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__.assign)({
            key: key,
            deleted: 'ok'
          }, opts);
          ['limit', 'skip', 'keys'].forEach(function (optKey) {
            delete subOpts[optKey];
          });
          return new Promise(function (resolve, reject) {
            api._allDocs(subOpts, function (err, res) {
              /* istanbul ignore if */
              if (err) {
                return reject(err);
              }
              /* istanbul ignore if */


              if (opts.update_seq && res.update_seq !== undefined) {
                finalResults.update_seq = res.update_seq;
              }

              finalResults.total_rows = res.total_rows;
              resolve(res.rows[0] || {
                key: key,
                error: 'not_found'
              });
            });
          });
        })).then(function (results) {
          finalResults.rows = results;
          return finalResults;
        });
      }

      function toObject(array) {
        return array.reduce(function (obj, item) {
          obj[item] = true;
          return obj;
        }, {});
      } // List of top level reserved words for doc


      var reservedWords = toObject(['_id', '_rev', '_attachments', '_deleted', '_revisions', '_revs_info', '_conflicts', '_deleted_conflicts', '_local_seq', '_rev_tree', //replication documents
      '_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats', // Specific to Couchbase Sync Gateway
      '_removed']); // List of reserved words that should end up the document

      var dataWords = toObject(['_attachments', //replication documents
      '_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats']);

      function parseRevisionInfo(rev$$1) {
        if (!/^\d+-/.test(rev$$1)) {
          return (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.INVALID_REV);
        }

        var idx = rev$$1.indexOf('-');
        var left = rev$$1.substring(0, idx);
        var right = rev$$1.substring(idx + 1);
        return {
          prefix: parseInt(left, 10),
          id: right
        };
      }

      function makeRevTreeFromRevisions(revisions, opts) {
        var pos = revisions.start - revisions.ids.length + 1;
        var revisionIds = revisions.ids;
        var ids = [revisionIds[0], opts, []];

        for (var i = 1, len = revisionIds.length; i < len; i++) {
          ids = [revisionIds[i], {
            status: 'missing'
          }, [ids]];
        }

        return [{
          pos: pos,
          ids: ids
        }];
      } // Preprocess documents, parse their revisions, assign an id and a
      // revision for new writes that are missing them, etc


      function _parseDoc(doc, newEdits, dbOpts) {
        if (!dbOpts) {
          dbOpts = {
            deterministic_revs: true
          };
        }

        var nRevNum;
        var newRevId;
        var revInfo;
        var opts = {
          status: 'available'
        };

        if (doc._deleted) {
          opts.deleted = true;
        }

        if (newEdits) {
          if (!doc._id) {
            doc._id = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__.uuid)();
          }

          newRevId = (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__.rev)(doc, dbOpts.deterministic_revs);

          if (doc._rev) {
            revInfo = parseRevisionInfo(doc._rev);

            if (revInfo.error) {
              return revInfo;
            }

            doc._rev_tree = [{
              pos: revInfo.prefix,
              ids: [revInfo.id, {
                status: 'missing'
              }, [[newRevId, opts, []]]]
            }];
            nRevNum = revInfo.prefix + 1;
          } else {
            doc._rev_tree = [{
              pos: 1,
              ids: [newRevId, opts, []]
            }];
            nRevNum = 1;
          }
        } else {
          if (doc._revisions) {
            doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
            nRevNum = doc._revisions.start;
            newRevId = doc._revisions.ids[0];
          }

          if (!doc._rev_tree) {
            revInfo = parseRevisionInfo(doc._rev);

            if (revInfo.error) {
              return revInfo;
            }

            nRevNum = revInfo.prefix;
            newRevId = revInfo.id;
            doc._rev_tree = [{
              pos: nRevNum,
              ids: [newRevId, opts, []]
            }];
          }
        }

        (0, pouchdb_utils__WEBPACK_IMPORTED_MODULE_0__.invalidIdError)(doc._id);
        doc._rev = nRevNum + '-' + newRevId;
        var result = {
          metadata: {},
          data: {}
        };

        for (var key in doc) {
          /* istanbul ignore else */
          if (Object.prototype.hasOwnProperty.call(doc, key)) {
            var specialKey = key[0] === '_';

            if (specialKey && !reservedWords[key]) {
              var error = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.DOC_VALIDATION, key);
              error.message = pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.DOC_VALIDATION.message + ': ' + key;
              throw error;
            } else if (specialKey && !dataWords[key]) {
              result.metadata[key.slice(1)] = doc[key];
            } else {
              result.data[key] = doc[key];
            }
          }
        }

        return result;
      }

      function parseBase64(data) {
        try {
          return (0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_1__.atob)(data);
        } catch (e) {
          var err = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.BAD_ARG, 'Attachment is not a valid base64 string');
          return {
            error: err
          };
        }
      }

      function preprocessString(att, blobType, callback) {
        var asBinary = parseBase64(att.data);

        if (asBinary.error) {
          return callback(asBinary.error);
        }

        att.length = asBinary.length;

        if (blobType === 'blob') {
          att.data = (0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_1__.binaryStringToBlobOrBuffer)(asBinary, att.content_type);
        } else if (blobType === 'base64') {
          att.data = (0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_1__.btoa)(asBinary);
        } else {
          // binary
          att.data = asBinary;
        }

        (0, pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__.binaryMd5)(asBinary, function (result) {
          att.digest = 'md5-' + result;
          callback();
        });
      }

      function preprocessBlob(att, blobType, callback) {
        (0, pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__.binaryMd5)(att.data, function (md5) {
          att.digest = 'md5-' + md5; // size is for blobs (browser), length is for buffers (node)

          att.length = att.data.size || att.data.length || 0;

          if (blobType === 'binary') {
            (0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_1__.blobOrBufferToBinaryString)(att.data, function (binString) {
              att.data = binString;
              callback();
            });
          } else if (blobType === 'base64') {
            (0, pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_1__.blobOrBufferToBase64)(att.data, function (b64) {
              att.data = b64;
              callback();
            });
          } else {
            callback();
          }
        });
      }

      function preprocessAttachment(att, blobType, callback) {
        if (att.stub) {
          return callback();
        }

        if (typeof att.data === 'string') {
          // input is a base64 string
          preprocessString(att, blobType, callback);
        } else {
          // input is a blob
          preprocessBlob(att, blobType, callback);
        }
      }

      function _preprocessAttachments(docInfos, blobType, callback) {
        if (!docInfos.length) {
          return callback();
        }

        var docv = 0;
        var overallErr;
        docInfos.forEach(function (docInfo) {
          var attachments = docInfo.data && docInfo.data._attachments ? Object.keys(docInfo.data._attachments) : [];
          var recv = 0;

          if (!attachments.length) {
            return done();
          }

          function processedAttachment(err) {
            overallErr = err;
            recv++;

            if (recv === attachments.length) {
              done();
            }
          }

          for (var key in docInfo.data._attachments) {
            if (docInfo.data._attachments.hasOwnProperty(key)) {
              preprocessAttachment(docInfo.data._attachments[key], blobType, processedAttachment);
            }
          }
        });

        function done() {
          docv++;

          if (docInfos.length === docv) {
            if (overallErr) {
              callback(overallErr);
            } else {
              callback();
            }
          }
        }
      }

      function _updateDoc(revLimit, prev, docInfo, results, i, cb, writeDoc, newEdits) {
        if ((0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.revExists)(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {
          results[i] = docInfo;
          return cb();
        } // sometimes this is pre-calculated. historically not always


        var previousWinningRev = prev.winningRev || (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.winningRev)(prev);
        var previouslyDeleted = 'deleted' in prev ? prev.deleted : (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isDeleted)(prev, previousWinningRev);
        var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted : (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isDeleted)(docInfo.metadata);
        var isRoot = /^1-/.test(docInfo.metadata.rev);

        if (previouslyDeleted && !deleted && newEdits && isRoot) {
          var newDoc = docInfo.data;
          newDoc._rev = previousWinningRev;
          newDoc._id = docInfo.metadata.id;
          docInfo = _parseDoc(newDoc, newEdits);
        }

        var merged = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.merge)(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);
        var inConflict = newEdits && (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf' || !previouslyDeleted && merged.conflicts !== 'new_leaf' || previouslyDeleted && !deleted && merged.conflicts === 'new_branch');

        if (inConflict) {
          var err = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.REV_CONFLICT);
          results[i] = err;
          return cb();
        }

        var newRev = docInfo.metadata.rev;
        docInfo.metadata.rev_tree = merged.tree;
        docInfo.stemmedRevs = merged.stemmedRevs || [];
        /* istanbul ignore else */

        if (prev.rev_map) {
          docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb
        } // recalculate


        var winningRev$$1 = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.winningRev)(docInfo.metadata);
        var winningRevIsDeleted = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isDeleted)(docInfo.metadata, winningRev$$1); // calculate the total number of documents that were added/removed,
        // from the perspective of total_rows/doc_count

        var delta = previouslyDeleted === winningRevIsDeleted ? 0 : previouslyDeleted < winningRevIsDeleted ? -1 : 1;
        var newRevIsDeleted;

        if (newRev === winningRev$$1) {
          // if the new rev is the same as the winning rev, we can reuse that value
          newRevIsDeleted = winningRevIsDeleted;
        } else {
          // if they're not the same, then we need to recalculate
          newRevIsDeleted = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isDeleted)(docInfo.metadata, newRev);
        }

        writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, true, delta, i, cb);
      }

      function rootIsMissing(docInfo) {
        return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
      }

      function _processDocs(revLimit, docInfos, api, fetchedDocs, tx, results, writeDoc, opts, overallCallback) {
        // Default to 1000 locally
        revLimit = revLimit || 1000;

        function insertDoc(docInfo, resultsIdx, callback) {
          // Cant insert new deleted documents
          var winningRev$$1 = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.winningRev)(docInfo.metadata);
          var deleted = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isDeleted)(docInfo.metadata, winningRev$$1);

          if ('was_delete' in opts && deleted) {
            results[resultsIdx] = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.MISSING_DOC, 'deleted');
            return callback();
          } // 4712 - detect whether a new document was inserted with a _rev


          var inConflict = newEdits && rootIsMissing(docInfo);

          if (inConflict) {
            var err = (0, pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.createError)(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__.REV_CONFLICT);
            results[resultsIdx] = err;
            return callback();
          }

          var delta = deleted ? 0 : 1;
          writeDoc(docInfo, winningRev$$1, deleted, deleted, false, delta, resultsIdx, callback);
        }

        var newEdits = opts.new_edits;
        var idsToDocs = new pouchdb_collections__WEBPACK_IMPORTED_MODULE_3__.Map();
        var docsDone = 0;
        var docsToDo = docInfos.length;

        function checkAllDocsDone() {
          if (++docsDone === docsToDo && overallCallback) {
            overallCallback();
          }
        }

        docInfos.forEach(function (currentDoc, resultsIdx) {
          if (currentDoc._id && (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.isLocalId)(currentDoc._id)) {
            var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
            api[fun](currentDoc, {
              ctx: tx
            }, function (err, res) {
              results[resultsIdx] = err || res;
              checkAllDocsDone();
            });
            return;
          }

          var id = currentDoc.metadata.id;

          if (idsToDocs.has(id)) {
            docsToDo--; // duplicate

            idsToDocs.get(id).push([currentDoc, resultsIdx]);
          } else {
            idsToDocs.set(id, [[currentDoc, resultsIdx]]);
          }
        }); // in the case of new_edits, the user can provide multiple docs
        // with the same id. these need to be processed sequentially

        idsToDocs.forEach(function (docs, id) {
          var numDone = 0;

          function docWritten() {
            if (++numDone < docs.length) {
              nextDoc();
            } else {
              checkAllDocsDone();
            }
          }

          function nextDoc() {
            var value = docs[numDone];
            var currentDoc = value[0];
            var resultsIdx = value[1];

            if (fetchedDocs.has(id)) {
              _updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results, resultsIdx, docWritten, writeDoc, newEdits);
            } else {
              // Ensure stemming applies to new writes as well
              var merged = (0, pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__.merge)([], currentDoc.metadata.rev_tree[0], revLimit);
              currentDoc.metadata.rev_tree = merged.tree;
              currentDoc.stemmedRevs = merged.stemmedRevs || [];
              insertDoc(currentDoc, resultsIdx, docWritten);
            }
          }

          nextDoc();
        });
      }
      /***/

    },

    /***/
    14477: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "safeJsonParse": function safeJsonParse() {
          return (
            /* binding */
            _safeJsonParse
          );
        },

        /* harmony export */
        "safeJsonStringify": function safeJsonStringify() {
          return (
            /* binding */
            _safeJsonStringify
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var vuvuzela__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! vuvuzela */
      28578);

      function _safeJsonParse(str) {
        // This try/catch guards against stack overflow errors.
        // JSON.parse() is faster than vuvuzela.parse() but vuvuzela
        // cannot overflow.
        try {
          return JSON.parse(str);
        } catch (e) {
          /* istanbul ignore next */
          return vuvuzela__WEBPACK_IMPORTED_MODULE_0__.parse(str);
        }
      }

      function _safeJsonStringify(json) {
        try {
          return JSON.stringify(json);
        } catch (e) {
          /* istanbul ignore next */
          return vuvuzela__WEBPACK_IMPORTED_MODULE_0__.stringify(json);
        }
      }
      /***/

    },

    /***/
    28578: function _(__unused_webpack_module, exports) {
      /**
       * Stringify/parse functions that don't operate
       * recursively, so they avoid call stack exceeded
       * errors.
       */
      exports.stringify = function stringify(input) {
        var queue = [];
        queue.push({
          obj: input
        });
        var res = '';
        var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;

        while (next = queue.pop()) {
          obj = next.obj;
          prefix = next.prefix || '';
          val = next.val || '';
          res += prefix;

          if (val) {
            res += val;
          } else if (typeof obj !== 'object') {
            res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
          } else if (obj === null) {
            res += 'null';
          } else if (Array.isArray(obj)) {
            queue.push({
              val: ']'
            });

            for (i = obj.length - 1; i >= 0; i--) {
              arrayPrefix = i === 0 ? '' : ',';
              queue.push({
                obj: obj[i],
                prefix: arrayPrefix
              });
            }

            queue.push({
              val: '['
            });
          } else {
            // object
            keys = [];

            for (k in obj) {
              if (obj.hasOwnProperty(k)) {
                keys.push(k);
              }
            }

            queue.push({
              val: '}'
            });

            for (i = keys.length - 1; i >= 0; i--) {
              key = keys[i];
              value = obj[key];
              objPrefix = i > 0 ? ',' : '';
              objPrefix += JSON.stringify(key) + ':';
              queue.push({
                obj: value,
                prefix: objPrefix
              });
            }

            queue.push({
              val: '{'
            });
          }
        }

        return res;
      }; // Convenience function for the parse function.
      // This pop function is basically copied from
      // pouchCollate.parseIndexableString


      function pop(obj, stack, metaStack) {
        var lastMetaElement = metaStack[metaStack.length - 1];

        if (obj === lastMetaElement.element) {
          // popping a meta-element, e.g. an object whose value is another object
          metaStack.pop();
          lastMetaElement = metaStack[metaStack.length - 1];
        }

        var element = lastMetaElement.element;
        var lastElementIndex = lastMetaElement.index;

        if (Array.isArray(element)) {
          element.push(obj);
        } else if (lastElementIndex === stack.length - 2) {
          // obj with key+value
          var key = stack.pop();
          element[key] = obj;
        } else {
          stack.push(obj); // obj with key only
        }
      }

      exports.parse = function (str) {
        var stack = [];
        var metaStack = []; // stack for arrays and objects

        var i = 0;
        var collationIndex, parsedNum, numChar;
        var parsedString, lastCh, numConsecutiveSlashes, ch;
        var arrayElement, objElement;

        while (true) {
          collationIndex = str[i++];

          if (collationIndex === '}' || collationIndex === ']' || typeof collationIndex === 'undefined') {
            if (stack.length === 1) {
              return stack.pop();
            } else {
              pop(stack.pop(), stack, metaStack);
              continue;
            }
          }

          switch (collationIndex) {
            case ' ':
            case '\t':
            case '\n':
            case ':':
            case ',':
              break;

            case 'n':
              i += 3; // 'ull'

              pop(null, stack, metaStack);
              break;

            case 't':
              i += 3; // 'rue'

              pop(true, stack, metaStack);
              break;

            case 'f':
              i += 4; // 'alse'

              pop(false, stack, metaStack);
              break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case '-':
              parsedNum = '';
              i--;

              while (true) {
                numChar = str[i++];

                if (/[\d\.\-e\+]/.test(numChar)) {
                  parsedNum += numChar;
                } else {
                  i--;
                  break;
                }
              }

              pop(parseFloat(parsedNum), stack, metaStack);
              break;

            case '"':
              parsedString = '';
              lastCh = void 0;
              numConsecutiveSlashes = 0;

              while (true) {
                ch = str[i++];

                if (ch !== '"' || lastCh === '\\' && numConsecutiveSlashes % 2 === 1) {
                  parsedString += ch;
                  lastCh = ch;

                  if (lastCh === '\\') {
                    numConsecutiveSlashes++;
                  } else {
                    numConsecutiveSlashes = 0;
                  }
                } else {
                  break;
                }
              }

              pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
              break;

            case '[':
              arrayElement = {
                element: [],
                index: stack.length
              };
              stack.push(arrayElement.element);
              metaStack.push(arrayElement);
              break;

            case '{':
              objElement = {
                element: {},
                index: stack.length
              };
              stack.push(objElement.element);
              metaStack.push(objElement);
              break;

            default:
              throw new Error('unexpectedly reached end of input: ' + collationIndex);
          }
        }
      };
      /***/

    }
  }]);
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDYjtBQUNBLDJCQUZhLENBRVM7O0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0FTOztBQUNBLHdDQUNBQSxzQkFEQSxJQUVBLHFDQUZBLEVBRUE7QUFDQTtBQUNBO0FBQ0EsYUFGQSxNQUVRO0FBQ1JDO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EzTixxQkFEQSxDQUNnQjs7QUFDaEIyTjtBQUNBOztBQUNBO0FBQ0EzTixxQkFEQSxDQUNnQjs7QUFDaEIyTjtBQUNBOztBQUNBO0FBQ0EzTixxQkFEQSxDQUNnQjs7QUFDaEIyTjtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUM7QUFDQTVOOztBQUNBO0FBQ0E2Tjs7QUFDQTtBQUNBRDtBQUNBLGlCQUZBLE1BRVk7QUFDWjVOO0FBQ0E7QUFDQTtBQUNBOztBQUNBMk47QUFDQTs7QUFDQTtBQUNBRztBQUNBQztBQUNBQzs7QUFDQTtBQUNBQzs7QUFDQSxxREFDQUQsK0JBREEsRUFDQTtBQUNBRjtBQUNBQzs7QUFDQTtBQUNBQztBQUNBLG1CQUZBLE1BRWM7QUFDZEE7QUFDQTtBQUNBLGlCQVRBLE1BU1k7QUFDWjtBQUNBO0FBQ0E7O0FBQ0FMO0FBQ0E7O0FBQ0E7QUFDQU87QUFBeUJWLDJCQUF6QjtBQUF5QmhPO0FBQXpCO0FBQ0FpTztBQUNBSDtBQUNBOztBQUNBO0FBQ0FhO0FBQXVCWCwyQkFBdkI7QUFBa0NoTztBQUFsQztBQUNBaU87QUFDQUg7QUFDQTs7QUFDQTtBQUNBLDhCQUNBLHNEQURBO0FBM0VBO0FBOEVBO0FBQ0EsT0FsR0E7Ozs7IiwibmFtZXMiOlsibWVzc2FnZSIsImNhbGxiYWNrIiwicG91Y2hkYl9lcnJvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsImV2dCIsImRhdGEiLCJtZXRhZGF0YSIsIndpbm5pbmdSZXYiLCJkZWxldGVkT3JMb2NhbCIsInNlcSIsImlkIiwic3RvcmVkT2JqZWN0IiwiZG9jIiwidHlwZSIsImJvZHkiLCJiaW5hcnkiLCJjYiIsInJlcSIsImF0dE9iaiIsImNoZWNrRG9uZSIsImF0dGFjaG1lbnRzIiwiZmV0Y2hBdHRhY2htZW50IiwicmVhZEJsb2JEYXRhIiwicm93IiwicmVzb2x2ZSIsImNvdW50IiwiZGVsZXRlT3JwaGFuZWRBdHRhY2htZW50cyIsInBvc3NpYmx5T3JwaGFuZWREaWdlc3RzIiwiSURCS2V5UmFuZ2UiLCJkaWdlc3QiLCJjb3VudFJlcSIsImF0dFN0b3JlIiwicmV2cyIsImluZGV4Iiwic2VxU3RvcmUiLCJvcGVuQ3Vyc29yIiwiY3Vyc29yIiwiYXR0QW5kU2VxU3RvcmUiLCJ0eG4iLCJlcnJvciIsInBvdWNoZGJfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsImkiLCJvcHRzIiwiZGJPcHRzIiwiZG9jSW5mb0Vycm9yIiwicG91Y2hkYl9jb2xsZWN0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiZG9jSW5mb3MiLCJibG9iVHlwZSIsInN0YXJ0VHJhbnNhY3Rpb24iLCJET0NfU1RPUkUiLCJCWV9TRVFfU1RPUkUiLCJBVFRBQ0hfU1RPUkUiLCJMT0NBTF9TVE9SRSIsIkFUVEFDSF9BTkRfU0VRX1NUT1JFIiwiTUVUQV9TVE9SRSIsImRvY1N0b3JlIiwiYnlTZXFTdG9yZSIsImF0dGFjaFN0b3JlIiwiYXR0YWNoQW5kU2VxU3RvcmUiLCJtZXRhU3RvcmUiLCJtZXRhRG9jIiwidXBkYXRlRG9jQ291bnRJZlJlYWR5IiwidmVyaWZ5QXR0YWNobWVudHMiLCJwcmVjb25kaXRpb25FcnJvcmVkIiwiZmV0Y2hFeGlzdGluZ0RvY3MiLCJhbGxEb2NzUHJvY2Vzc2VkIiwiYXBpIiwiZmV0Y2hlZERvY3MiLCJyZXN1bHRzIiwid3JpdGVEb2MiLCJvbkFsbERvY3NQcm9jZXNzZWQiLCJpZGJQcm9jZXNzRG9jcyIsImRvY0luZm8iLCJjaGFuZ2VzSGFuZGxlciQxIiwiZXJyIiwiT2JqZWN0IiwiZGlnZXN0cyIsImZpbmlzaCIsInZlcmlmeUF0dGFjaG1lbnQiLCJpc1VwZGF0ZSIsImRlbHRhIiwicmVzdWx0c0lkeCIsImRvY0NvdW50RGVsdGEiLCJmaW5pc2hEb2MiLCJyZXZzVG9EZWxldGUiLCJjb21wYWN0UmV2cyIsIndpbm5pbmdSZXZJc0RlbGV0ZWQiLCJtZXRhRGF0YVJlcSIsImUiLCJnZXRLZXlSZXEiLCJwdXRSZXEiLCJvayIsInJldiIsImluc2VydEF0dGFjaG1lbnRNYXBwaW5ncyIsIm51bURvbmUiLCJjb2xsZWN0UmVzdWx0cyIsImF0dCIsInNhdmVBdHRhY2htZW50IiwiZGlnZXN0U2VxIiwiYWRkIiwiYmF0Y2hTaXplIiwidmFsdWVzQmF0Y2giLCJvbkJhdGNoIiwia2V5c0JhdGNoIiwibmV3S2V5UmFuZ2UiLCJrZXlSYW5nZSIsIm9iamVjdFN0b3JlIiwicHNldWRvQ3Vyc29yIiwidmFsdWVzIiwib25TdWNjZXNzIiwidGFyZ2V0IiwicmVzdWx0Iiwia2V5cyIsImtleSIsImtleVJhbmdlRXJyb3IiLCJzdG9yZXMiLCJkb2NDb3VudCIsImdldE1heFVwZGF0ZVNlcSIsInVwZGF0ZVNlcSIsIm1heEtleSIsImRvY0lkUmV2SW5kZXgiLCJmZXRjaEF0dGFjaG1lbnRzSWZOZWNlc3NhcnkiLCJ2YWx1ZSIsImZldGNoRG9jQXN5bmNocm9ub3VzbHkiLCJhbGxEb2NzSW5uZXIiLCJwcm9jZXNzQmF0Y2giLCJ0b3RhbF9yb3dzIiwib2Zmc2V0Iiwicm93cyIsInJldHVyblZhbCIsInBvc3RQcm9jZXNzQXR0YWNobWVudHMiLCJvblJlc3VsdHNSZWFkeSIsInJ1bkJhdGNoZWRDdXJzb3IiLCJwYXJzZUludCIsImZ1biIsIlBvdWNoREIiLCJydW5uaW5nIiwicXVldWUiLCJhY3Rpb24iLCJ0cnlDb2RlIiwiYXBwbHlOZXh0IiwiY2FuY2VsIiwibGltaXQiLCJsYXN0U2VxIiwibnVtUmVzdWx0cyIsInByb21pc2VzIiwiUHJvbWlzZSIsImJhdGNoVmFsdWVzIiwiZmV0Y2hXaW5uaW5nRG9jQW5kTWV0YWRhdGEiLCJtZXRhZGF0YXMiLCJ3aW5uaW5nRG9jcyIsIm9uQmF0Y2hEb25lIiwiZG9jSWRzVG9NZXRhZGF0YSIsIm9uR2V0TWV0YWRhdGEiLCJsYXN0X3NlcSIsIm9iamVjdFN0b3JlcyIsImVucXVldWVUYXNrIiwiaW5pdCIsImtleVBhdGgiLCJkYiIsImF1dG9JbmNyZW1lbnQiLCJjcmVhdGVJbmRleCIsInVuaXF1ZSIsImRvY0lkIiwic2VxQ3Vyc29yIiwibG9jYWxTdG9yZSIsImoiLCJkaWdlc3RNYXAiLCJtZXRhZGF0YVNlcSIsImZldGNoTWV0YWRhdGFTZXEiLCJpZGJCdWxrRG9jcyIsImN0eCIsImRvY19jb3VudCIsInVwZGF0ZV9zZXEiLCJpZGJfYXR0YWNobWVudF9mb3JtYXQiLCJpZGJBbGxEb2NzIiwiaWRiIiwiY2FjaGVkREJzIiwicmV2SGFzaCIsImVuY29kZU1ldGFkYXRhIiwidHgiLCJyZXQiLCJvU3RvcmUiLCJvcGVuUmVxIiwib3BlblJlcUxpc3QiLCJkYk5hbWUiLCJjcmVhdGVMb2NhbFN0b3JlU2NoZW1hIiwiYWRkQXR0YWNoQW5kU2VxU3RvcmUiLCJhZGREZWxldGVkT3JMb2NhbEluZGV4IiwibWlncmF0ZUxvY2FsU3RvcmUiLCJtaWdyYXRlQXR0c0FuZFNlcXMiLCJtaWdyYXRlTWV0YWRhdGEiLCJtaWdyYXRpb24iLCJuZXh0IiwiREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSIsIm5hbWUiLCJpbnN0YW5jZUlkIiwiYmxvYlN1cHBvcnQiLCJnbG9iYWwiLCJzdG9yZU1ldGFEb2NJZlJlYWR5IiwiY291bnREb2NzIiwiYmxvYlN1cHBvcnRQcm9taXNlIiwiY29tcGxldGVTZXR1cCIsInN0b3JlZE1ldGFEb2MiLCJtc2ciLCJJZGJQb3VjaCIsIl9fd2VicGFja19leHBvcnRzX18iLCJkZWxldGVkIiwiZmluYWxSZXN1bHRzIiwidGhlbiIsIm9iaiIsInByZWZpeCIsImlkcyIsInN0YXR1cyIsInBvcyIsImRldGVybWluaXN0aWNfcmV2cyIsIm5ld1JldklkIiwicmV2SW5mbyIsIm5SZXZOdW0iLCJhc0JpbmFyeSIsInByZXByb2Nlc3NTdHJpbmciLCJwcmVwcm9jZXNzQmxvYiIsIm92ZXJhbGxFcnIiLCJyZWN2IiwiZG9uZSIsInByZXByb2Nlc3NBdHRhY2htZW50IiwicHJvY2Vzc2VkQXR0YWNobWVudCIsImRvY3YiLCJuZXdFZGl0cyIsInByZXYiLCJwcmV2aW91c1dpbm5pbmdSZXYiLCJuZXdEb2MiLCJyZXZMaW1pdCIsInByZXZpb3VzbHlEZWxldGVkIiwid2lubmluZ1JldiQkMSIsIm5ld1JldklzRGVsZXRlZCIsIm5ld1JldiIsIm92ZXJhbGxDYWxsYmFjayIsInBvdWNoZGJfY29sbGVjdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyIsImN1cnJlbnREb2MiLCJjaGVja0FsbERvY3NEb25lIiwiZG9jc1RvRG8iLCJpZHNUb0RvY3MiLCJuZXh0RG9jIiwidXBkYXRlRG9jIiwiZG9jV3JpdHRlbiIsImluc2VydERvYyIsInZ1dnV6ZWxhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJzdHIiLCJqc29uIiwiZXhwb3J0cyIsInZhbCIsInJlcyIsImFycmF5UHJlZml4Iiwib2JqUHJlZml4IiwibWV0YVN0YWNrIiwibGFzdE1ldGFFbGVtZW50IiwiZWxlbWVudCIsInN0YWNrIiwiY29sbGF0aW9uSW5kZXgiLCJwb3AiLCJwYXJzZWROdW0iLCJudW1DaGFyIiwicGFyc2VkU3RyaW5nIiwibGFzdENoIiwibnVtQ29uc2VjdXRpdmVTbGFzaGVzIiwiY2giLCJhcnJheUVsZW1lbnQiLCJvYmpFbGVtZW50Il0sInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvcG91Y2hkYi1hZGFwdGVyLWlkYi9saWIvaW5kZXguZXMuanMiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9wb3VjaGRiLWFkYXB0ZXItdXRpbHMvbGliL2luZGV4LmVzLmpzIiwid2VicGFjazovLy9ub2RlX21vZHVsZXMvcG91Y2hkYi1qc29uL2xpYi9pbmRleC5lcy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3Z1dnV6ZWxhL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByZXByb2Nlc3NBdHRhY2htZW50cywgcHJvY2Vzc0RvY3MsIGlzTG9jYWxJZCwgcGFyc2VEb2MgfSBmcm9tICdwb3VjaGRiLWFkYXB0ZXItdXRpbHMnO1xuaW1wb3J0IHsgc2FmZUpzb25QYXJzZSwgc2FmZUpzb25TdHJpbmdpZnkgfSBmcm9tICdwb3VjaGRiLWpzb24nO1xuaW1wb3J0IHsgY29tcGFjdFRyZWUsIGNvbGxlY3RDb25mbGljdHMsIGlzRGVsZXRlZCwgaXNMb2NhbElkIGFzIGlzTG9jYWxJZCQxLCB0cmF2ZXJzZVJldlRyZWUsIHdpbm5pbmdSZXYsIGxhdGVzdCB9IGZyb20gJ3BvdWNoZGItbWVyZ2UnO1xuaW1wb3J0IHsgYnRvYSwgcmVhZEFzQmluYXJ5U3RyaW5nLCBiYXNlNjRTdHJpbmdUb0Jsb2JPckJ1ZmZlciwgYmxvYiB9IGZyb20gJ3BvdWNoZGItYmluYXJ5LXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUVycm9yLCBJREJfRVJST1IsIE1JU1NJTkdfU1RVQiwgTUlTU0lOR19ET0MsIFJFVl9DT05GTElDVCB9IGZyb20gJ3BvdWNoZGItZXJyb3JzJztcbmltcG9ydCB7IE1hcCwgU2V0IH0gZnJvbSAncG91Y2hkYi1jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBhc3NpZ24sIHBpY2ssIGNoYW5nZXNIYW5kbGVyLCBuZXh0VGljaywgY2xvbmUsIGZpbHRlckNoYW5nZSwgdXVpZCwgZ3VhcmRlZENvbnNvbGUsIHRvUHJvbWlzZSwgaGFzTG9jYWxTdG9yYWdlIH0gZnJvbSAncG91Y2hkYi11dGlscyc7XG5cbi8vIEluZGV4ZWREQiByZXF1aXJlcyBhIHZlcnNpb25lZCBkYXRhYmFzZSBzdHJ1Y3R1cmUsIHNvIHdlIHVzZSB0aGVcbi8vIHZlcnNpb24gaGVyZSB0byBtYW5hZ2UgbWlncmF0aW9ucy5cbnZhciBBREFQVEVSX1ZFUlNJT04gPSA1O1xuXG4vLyBUaGUgb2JqZWN0IHN0b3JlcyBjcmVhdGVkIGZvciBlYWNoIGRhdGFiYXNlXG4vLyBET0NfU1RPUkUgc3RvcmVzIHRoZSBkb2N1bWVudCBtZXRhIGRhdGEsIGl0cyByZXZpc2lvbiBoaXN0b3J5IGFuZCBzdGF0ZVxuLy8gS2V5ZWQgYnkgZG9jdW1lbnQgaWRcbnZhciBET0NfU1RPUkUgPSAnZG9jdW1lbnQtc3RvcmUnO1xuLy8gQllfU0VRX1NUT1JFIHN0b3JlcyBhIHBhcnRpY3VsYXIgdmVyc2lvbiBvZiBhIGRvY3VtZW50LCBrZXllZCBieSBpdHNcbi8vIHNlcXVlbmNlIGlkXG52YXIgQllfU0VRX1NUT1JFID0gJ2J5LXNlcXVlbmNlJztcbi8vIFdoZXJlIHdlIHN0b3JlIGF0dGFjaG1lbnRzXG52YXIgQVRUQUNIX1NUT1JFID0gJ2F0dGFjaC1zdG9yZSc7XG4vLyBXaGVyZSB3ZSBzdG9yZSBtYW55LXRvLW1hbnkgcmVsYXRpb25zXG4vLyBiZXR3ZWVuIGF0dGFjaG1lbnQgZGlnZXN0cyBhbmQgc2Vxc1xudmFyIEFUVEFDSF9BTkRfU0VRX1NUT1JFID0gJ2F0dGFjaC1zZXEtc3RvcmUnO1xuXG4vLyBXaGVyZSB3ZSBzdG9yZSBkYXRhYmFzZS13aWRlIG1ldGEgZGF0YSBpbiBhIHNpbmdsZSByZWNvcmRcbi8vIGtleWVkIGJ5IGlkOiBNRVRBX1NUT1JFXG52YXIgTUVUQV9TVE9SRSA9ICdtZXRhLXN0b3JlJztcbi8vIFdoZXJlIHdlIHN0b3JlIGxvY2FsIGRvY3VtZW50c1xudmFyIExPQ0FMX1NUT1JFID0gJ2xvY2FsLXN0b3JlJztcbi8vIFdoZXJlIHdlIGRldGVjdCBibG9iIHN1cHBvcnRcbnZhciBERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFID0gJ2RldGVjdC1ibG9iLXN1cHBvcnQnO1xuXG5mdW5jdGlvbiBpZGJFcnJvcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ3Vua25vd25fZXJyb3InO1xuICAgIGlmIChldnQudGFyZ2V0ICYmIGV2dC50YXJnZXQuZXJyb3IpIHtcbiAgICAgIG1lc3NhZ2UgPSBldnQudGFyZ2V0LmVycm9yLm5hbWUgfHwgZXZ0LnRhcmdldC5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBjYWxsYmFjayhjcmVhdGVFcnJvcihJREJfRVJST1IsIG1lc3NhZ2UsIGV2dC50eXBlKSk7XG4gIH07XG59XG5cbi8vIFVuZm9ydHVuYXRlbHksIHRoZSBtZXRhZGF0YSBoYXMgdG8gYmUgc3RyaW5naWZpZWRcbi8vIHdoZW4gaXQgaXMgcHV0IGludG8gdGhlIGRhdGFiYXNlLCBiZWNhdXNlIG90aGVyd2lzZVxuLy8gSW5kZXhlZERCIGNhbiB0aHJvdyBlcnJvcnMgZm9yIGRlZXBseS1uZXN0ZWQgb2JqZWN0cy5cbi8vIE9yaWdpbmFsbHkgd2UganVzdCB1c2VkIEpTT04ucGFyc2UvSlNPTi5zdHJpbmdpZnk7IG5vd1xuLy8gd2UgdXNlIHRoaXMgY3VzdG9tIHZ1dnV6ZWxhIGxpYnJhcnkgdGhhdCBhdm9pZHMgcmVjdXJzaW9uLlxuLy8gSWYgd2UgY291bGQgZG8gaXQgYWxsIG92ZXIgYWdhaW4sIHdlJ2QgcHJvYmFibHkgdXNlIGFcbi8vIGZvcm1hdCBmb3IgdGhlIHJldmlzaW9uIHRyZWVzIG90aGVyIHRoYW4gSlNPTi5cbmZ1bmN0aW9uIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhLCB3aW5uaW5nUmV2JCQxLCBkZWxldGVkKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YTogc2FmZUpzb25TdHJpbmdpZnkobWV0YWRhdGEpLFxuICAgIHdpbm5pbmdSZXY6IHdpbm5pbmdSZXYkJDEsXG4gICAgZGVsZXRlZE9yTG9jYWw6IGRlbGV0ZWQgPyAnMScgOiAnMCcsXG4gICAgc2VxOiBtZXRhZGF0YS5zZXEsIC8vIGhpZ2hlc3Qgc2VxIGZvciB0aGlzIGRvY1xuICAgIGlkOiBtZXRhZGF0YS5pZFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWNvZGVNZXRhZGF0YShzdG9yZWRPYmplY3QpIHtcbiAgaWYgKCFzdG9yZWRPYmplY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWV0YWRhdGEgPSBzYWZlSnNvblBhcnNlKHN0b3JlZE9iamVjdC5kYXRhKTtcbiAgbWV0YWRhdGEud2lubmluZ1JldiA9IHN0b3JlZE9iamVjdC53aW5uaW5nUmV2O1xuICBtZXRhZGF0YS5kZWxldGVkID0gc3RvcmVkT2JqZWN0LmRlbGV0ZWRPckxvY2FsID09PSAnMSc7XG4gIG1ldGFkYXRhLnNlcSA9IHN0b3JlZE9iamVjdC5zZXE7XG4gIHJldHVybiBtZXRhZGF0YTtcbn1cblxuLy8gcmVhZCB0aGUgZG9jIGJhY2sgb3V0IGZyb20gdGhlIGRhdGFiYXNlLiB3ZSBkb24ndCBzdG9yZSB0aGVcbi8vIF9pZCBvciBfcmV2IGJlY2F1c2Ugd2UgYWxyZWFkeSBoYXZlIF9kb2NfaWRfcmV2LlxuZnVuY3Rpb24gZGVjb2RlRG9jKGRvYykge1xuICBpZiAoIWRvYykge1xuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgdmFyIGlkeCA9IGRvYy5fZG9jX2lkX3Jldi5sYXN0SW5kZXhPZignOicpO1xuICBkb2MuX2lkID0gZG9jLl9kb2NfaWRfcmV2LnN1YnN0cmluZygwLCBpZHggLSAxKTtcbiAgZG9jLl9yZXYgPSBkb2MuX2RvY19pZF9yZXYuc3Vic3RyaW5nKGlkeCArIDEpO1xuICBkZWxldGUgZG9jLl9kb2NfaWRfcmV2O1xuICByZXR1cm4gZG9jO1xufVxuXG4vLyBSZWFkIGEgYmxvYiBmcm9tIHRoZSBkYXRhYmFzZSwgZW5jb2RpbmcgYXMgbmVjZXNzYXJ5XG4vLyBhbmQgdHJhbnNsYXRpbmcgZnJvbSBiYXNlNjQgaWYgdGhlIElEQiBkb2Vzbid0IHN1cHBvcnRcbi8vIG5hdGl2ZSBCbG9ic1xuZnVuY3Rpb24gcmVhZEJsb2JEYXRhKGJvZHksIHR5cGUsIGFzQmxvYiwgY2FsbGJhY2spIHtcbiAgaWYgKGFzQmxvYikge1xuICAgIGlmICghYm9keSkge1xuICAgICAgY2FsbGJhY2soYmxvYihbJyddLCB7dHlwZTogdHlwZX0pKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJykgeyAvLyB3ZSBoYXZlIGJsb2Igc3VwcG9ydFxuICAgICAgY2FsbGJhY2soYm9keSk7XG4gICAgfSBlbHNlIHsgLy8gbm8gYmxvYiBzdXBwb3J0XG4gICAgICBjYWxsYmFjayhiYXNlNjRTdHJpbmdUb0Jsb2JPckJ1ZmZlcihib2R5LCB0eXBlKSk7XG4gICAgfVxuICB9IGVsc2UgeyAvLyBhcyBiYXNlNjQgc3RyaW5nXG4gICAgaWYgKCFib2R5KSB7XG4gICAgICBjYWxsYmFjaygnJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSAhPT0gJ3N0cmluZycpIHsgLy8gd2UgaGF2ZSBibG9iIHN1cHBvcnRcbiAgICAgIHJlYWRBc0JpbmFyeVN0cmluZyhib2R5LCBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgICAgIGNhbGxiYWNrKGJ0b2EoYmluYXJ5KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgeyAvLyBubyBibG9iIHN1cHBvcnRcbiAgICAgIGNhbGxiYWNrKGJvZHkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmZXRjaEF0dGFjaG1lbnRzSWZOZWNlc3NhcnkoZG9jLCBvcHRzLCB0eG4sIGNiKSB7XG4gIHZhciBhdHRhY2htZW50cyA9IE9iamVjdC5rZXlzKGRvYy5fYXR0YWNobWVudHMgfHwge30pO1xuICBpZiAoIWF0dGFjaG1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYiAmJiBjYigpO1xuICB9XG4gIHZhciBudW1Eb25lID0gMDtcblxuICBmdW5jdGlvbiBjaGVja0RvbmUoKSB7XG4gICAgaWYgKCsrbnVtRG9uZSA9PT0gYXR0YWNobWVudHMubGVuZ3RoICYmIGNiKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoQXR0YWNobWVudChkb2MsIGF0dCkge1xuICAgIHZhciBhdHRPYmogPSBkb2MuX2F0dGFjaG1lbnRzW2F0dF07XG4gICAgdmFyIGRpZ2VzdCA9IGF0dE9iai5kaWdlc3Q7XG4gICAgdmFyIHJlcSA9IHR4bi5vYmplY3RTdG9yZShBVFRBQ0hfU1RPUkUpLmdldChkaWdlc3QpO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgYXR0T2JqLmJvZHkgPSBlLnRhcmdldC5yZXN1bHQuYm9keTtcbiAgICAgIGNoZWNrRG9uZSgpO1xuICAgIH07XG4gIH1cblxuICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdHQpIHtcbiAgICBpZiAob3B0cy5hdHRhY2htZW50cyAmJiBvcHRzLmluY2x1ZGVfZG9jcykge1xuICAgICAgZmV0Y2hBdHRhY2htZW50KGRvYywgYXR0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jLl9hdHRhY2htZW50c1thdHRdLnN0dWIgPSB0cnVlO1xuICAgICAgY2hlY2tEb25lKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gSURCLXNwZWNpZmljIHBvc3Rwcm9jZXNzaW5nIG5lY2Vzc2FyeSBiZWNhdXNlXG4vLyB3ZSBkb24ndCBrbm93IHdoZXRoZXIgd2Ugc3RvcmVkIGEgdHJ1ZSBCbG9iIG9yXG4vLyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZywgYW5kIGlmIGl0J3MgYSBCbG9iIGl0XG4vLyBuZWVkcyB0byBiZSByZWFkIG91dHNpZGUgb2YgdGhlIHRyYW5zYWN0aW9uIGNvbnRleHRcbmZ1bmN0aW9uIHBvc3RQcm9jZXNzQXR0YWNobWVudHMocmVzdWx0cywgYXNCbG9iKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgaWYgKHJvdy5kb2MgJiYgcm93LmRvYy5fYXR0YWNobWVudHMpIHtcbiAgICAgIHZhciBhdHROYW1lcyA9IE9iamVjdC5rZXlzKHJvdy5kb2MuX2F0dGFjaG1lbnRzKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChhdHROYW1lcy5tYXAoZnVuY3Rpb24gKGF0dCkge1xuICAgICAgICB2YXIgYXR0T2JqID0gcm93LmRvYy5fYXR0YWNobWVudHNbYXR0XTtcbiAgICAgICAgaWYgKCEoJ2JvZHknIGluIGF0dE9iaikpIHsgLy8gYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBhdHRPYmouYm9keTtcbiAgICAgICAgdmFyIHR5cGUgPSBhdHRPYmouY29udGVudF90eXBlO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZWFkQmxvYkRhdGEoYm9keSwgdHlwZSwgYXNCbG9iLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcm93LmRvYy5fYXR0YWNobWVudHNbYXR0XSA9IGFzc2lnbihcbiAgICAgICAgICAgICAgcGljayhhdHRPYmosIFsnZGlnZXN0JywgJ2NvbnRlbnRfdHlwZSddKSxcbiAgICAgICAgICAgICAge2RhdGE6IGRhdGF9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gY29tcGFjdFJldnMocmV2cywgZG9jSWQsIHR4bikge1xuXG4gIHZhciBwb3NzaWJseU9ycGhhbmVkRGlnZXN0cyA9IFtdO1xuICB2YXIgc2VxU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFKTtcbiAgdmFyIGF0dFN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEFUVEFDSF9TVE9SRSk7XG4gIHZhciBhdHRBbmRTZXFTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShBVFRBQ0hfQU5EX1NFUV9TVE9SRSk7XG4gIHZhciBjb3VudCA9IHJldnMubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNoZWNrRG9uZSgpIHtcbiAgICBjb3VudC0tO1xuICAgIGlmICghY291bnQpIHsgLy8gZG9uZSBwcm9jZXNzaW5nIGFsbCByZXZzXG4gICAgICBkZWxldGVPcnBoYW5lZEF0dGFjaG1lbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlT3JwaGFuZWRBdHRhY2htZW50cygpIHtcbiAgICBpZiAoIXBvc3NpYmx5T3JwaGFuZWREaWdlc3RzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwb3NzaWJseU9ycGhhbmVkRGlnZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChkaWdlc3QpIHtcbiAgICAgIHZhciBjb3VudFJlcSA9IGF0dEFuZFNlcVN0b3JlLmluZGV4KCdkaWdlc3RTZXEnKS5jb3VudChcbiAgICAgICAgSURCS2V5UmFuZ2UuYm91bmQoXG4gICAgICAgICAgZGlnZXN0ICsgJzo6JywgZGlnZXN0ICsgJzo6XFx1ZmZmZicsIGZhbHNlLCBmYWxzZSkpO1xuICAgICAgY291bnRSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgLy8gb3JwaGFuZWRcbiAgICAgICAgICBhdHRTdG9yZS5kZWxldGUoZGlnZXN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldnMuZm9yRWFjaChmdW5jdGlvbiAocmV2KSB7XG4gICAgdmFyIGluZGV4ID0gc2VxU3RvcmUuaW5kZXgoJ19kb2NfaWRfcmV2Jyk7XG4gICAgdmFyIGtleSA9IGRvY0lkICsgXCI6OlwiICsgcmV2O1xuICAgIGluZGV4LmdldEtleShrZXkpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgc2VxID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBzZXEgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBjaGVja0RvbmUoKTtcbiAgICAgIH1cbiAgICAgIHNlcVN0b3JlLmRlbGV0ZShzZXEpO1xuXG4gICAgICB2YXIgY3Vyc29yID0gYXR0QW5kU2VxU3RvcmUuaW5kZXgoJ3NlcScpXG4gICAgICAgIC5vcGVuQ3Vyc29yKElEQktleVJhbmdlLm9ubHkoc2VxKSk7XG5cbiAgICAgIGN1cnNvci5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICB2YXIgZGlnZXN0ID0gY3Vyc29yLnZhbHVlLmRpZ2VzdFNlcS5zcGxpdCgnOjonKVswXTtcbiAgICAgICAgICBwb3NzaWJseU9ycGhhbmVkRGlnZXN0cy5wdXNoKGRpZ2VzdCk7XG4gICAgICAgICAgYXR0QW5kU2VxU3RvcmUuZGVsZXRlKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZG9uZVxuICAgICAgICAgIGNoZWNrRG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvcGVuVHJhbnNhY3Rpb25TYWZlbHkoaWRiLCBzdG9yZXMsIG1vZGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHhuOiBpZGIudHJhbnNhY3Rpb24oc3RvcmVzLCBtb2RlKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyXG4gICAgfTtcbiAgfVxufVxuXG52YXIgY2hhbmdlc0hhbmRsZXIkMSA9IG5ldyBjaGFuZ2VzSGFuZGxlcigpO1xuXG5mdW5jdGlvbiBpZGJCdWxrRG9jcyhkYk9wdHMsIHJlcSwgb3B0cywgYXBpLCBpZGIsIGNhbGxiYWNrKSB7XG4gIHZhciBkb2NJbmZvcyA9IHJlcS5kb2NzO1xuICB2YXIgdHhuO1xuICB2YXIgZG9jU3RvcmU7XG4gIHZhciBieVNlcVN0b3JlO1xuICB2YXIgYXR0YWNoU3RvcmU7XG4gIHZhciBhdHRhY2hBbmRTZXFTdG9yZTtcbiAgdmFyIG1ldGFTdG9yZTtcbiAgdmFyIGRvY0luZm9FcnJvcjtcbiAgdmFyIG1ldGFEb2M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRvY0luZm9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGRvYyA9IGRvY0luZm9zW2ldO1xuICAgIGlmIChkb2MuX2lkICYmIGlzTG9jYWxJZChkb2MuX2lkKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRvYyA9IGRvY0luZm9zW2ldID0gcGFyc2VEb2MoZG9jLCBvcHRzLm5ld19lZGl0cywgZGJPcHRzKTtcbiAgICBpZiAoZG9jLmVycm9yICYmICFkb2NJbmZvRXJyb3IpIHtcbiAgICAgIGRvY0luZm9FcnJvciA9IGRvYztcbiAgICB9XG4gIH1cblxuICBpZiAoZG9jSW5mb0Vycm9yKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRvY0luZm9FcnJvcik7XG4gIH1cblxuICB2YXIgYWxsRG9jc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICB2YXIgZG9jQ291bnREZWx0YSA9IDA7XG4gIHZhciByZXN1bHRzID0gbmV3IEFycmF5KGRvY0luZm9zLmxlbmd0aCk7XG4gIHZhciBmZXRjaGVkRG9jcyA9IG5ldyBNYXAoKTtcbiAgdmFyIHByZWNvbmRpdGlvbkVycm9yZWQgPSBmYWxzZTtcbiAgdmFyIGJsb2JUeXBlID0gYXBpLl9tZXRhLmJsb2JTdXBwb3J0ID8gJ2Jsb2InIDogJ2Jhc2U2NCc7XG5cbiAgcHJlcHJvY2Vzc0F0dGFjaG1lbnRzKGRvY0luZm9zLCBibG9iVHlwZSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBzdGFydFRyYW5zYWN0aW9uKCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0VHJhbnNhY3Rpb24oKSB7XG5cbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgRE9DX1NUT1JFLCBCWV9TRVFfU1RPUkUsXG4gICAgICBBVFRBQ0hfU1RPUkUsXG4gICAgICBMT0NBTF9TVE9SRSwgQVRUQUNIX0FORF9TRVFfU1RPUkUsXG4gICAgICBNRVRBX1NUT1JFXG4gICAgXTtcbiAgICB2YXIgdHhuUmVzdWx0ID0gb3BlblRyYW5zYWN0aW9uU2FmZWx5KGlkYiwgc3RvcmVzLCAncmVhZHdyaXRlJyk7XG4gICAgaWYgKHR4blJlc3VsdC5lcnJvcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHR4blJlc3VsdC5lcnJvcik7XG4gICAgfVxuICAgIHR4biA9IHR4blJlc3VsdC50eG47XG4gICAgdHhuLm9uYWJvcnQgPSBpZGJFcnJvcihjYWxsYmFjayk7XG4gICAgdHhuLm9udGltZW91dCA9IGlkYkVycm9yKGNhbGxiYWNrKTtcbiAgICB0eG4ub25jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIGRvY1N0b3JlID0gdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSk7XG4gICAgYnlTZXFTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShCWV9TRVFfU1RPUkUpO1xuICAgIGF0dGFjaFN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEFUVEFDSF9TVE9SRSk7XG4gICAgYXR0YWNoQW5kU2VxU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQVRUQUNIX0FORF9TRVFfU1RPUkUpO1xuICAgIG1ldGFTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShNRVRBX1NUT1JFKTtcblxuICAgIG1ldGFTdG9yZS5nZXQoTUVUQV9TVE9SRSkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIG1ldGFEb2MgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICB1cGRhdGVEb2NDb3VudElmUmVhZHkoKTtcbiAgICB9O1xuXG4gICAgdmVyaWZ5QXR0YWNobWVudHMoZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcmVjb25kaXRpb25FcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBmZXRjaEV4aXN0aW5nRG9jcygpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25BbGxEb2NzUHJvY2Vzc2VkKCkge1xuICAgIGFsbERvY3NQcm9jZXNzZWQgPSB0cnVlO1xuICAgIHVwZGF0ZURvY0NvdW50SWZSZWFkeSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaWRiUHJvY2Vzc0RvY3MoKSB7XG4gICAgcHJvY2Vzc0RvY3MoZGJPcHRzLnJldnNfbGltaXQsIGRvY0luZm9zLCBhcGksIGZldGNoZWREb2NzLFxuICAgICAgICAgICAgICAgIHR4biwgcmVzdWx0cywgd3JpdGVEb2MsIG9wdHMsIG9uQWxsRG9jc1Byb2Nlc3NlZCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEb2NDb3VudElmUmVhZHkoKSB7XG4gICAgaWYgKCFtZXRhRG9jIHx8ICFhbGxEb2NzUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNhY2hpbmcgdGhlIGRvY0NvdW50IHNhdmVzIGEgbG90IG9mIHRpbWUgaW4gYWxsRG9jcygpIGFuZFxuICAgIC8vIGluZm8oKSwgd2hpY2ggaXMgd2h5IHdlIGdvIHRvIGFsbCB0aGUgdHJvdWJsZSBvZiBkb2luZyB0aGlzXG4gICAgbWV0YURvYy5kb2NDb3VudCArPSBkb2NDb3VudERlbHRhO1xuICAgIG1ldGFTdG9yZS5wdXQobWV0YURvYyk7XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaEV4aXN0aW5nRG9jcygpIHtcblxuICAgIGlmICghZG9jSW5mb3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG51bUZldGNoZWQgPSAwO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tEb25lKCkge1xuICAgICAgaWYgKCsrbnVtRmV0Y2hlZCA9PT0gZG9jSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgIGlkYlByb2Nlc3NEb2NzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZE1ldGFkYXRhKGV2ZW50KSB7XG4gICAgICB2YXIgbWV0YWRhdGEgPSBkZWNvZGVNZXRhZGF0YShldmVudC50YXJnZXQucmVzdWx0KTtcblxuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIGZldGNoZWREb2NzLnNldChtZXRhZGF0YS5pZCwgbWV0YWRhdGEpO1xuICAgICAgfVxuICAgICAgY2hlY2tEb25lKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRvY0luZm9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZG9jSW5mbyA9IGRvY0luZm9zW2ldO1xuICAgICAgaWYgKGRvY0luZm8uX2lkICYmIGlzTG9jYWxJZChkb2NJbmZvLl9pZCkpIHtcbiAgICAgICAgY2hlY2tEb25lKCk7IC8vIHNraXAgbG9jYWwgZG9jc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXEgPSBkb2NTdG9yZS5nZXQoZG9jSW5mby5tZXRhZGF0YS5pZCk7XG4gICAgICByZXEub25zdWNjZXNzID0gcmVhZE1ldGFkYXRhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgIGlmIChwcmVjb25kaXRpb25FcnJvcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2hhbmdlc0hhbmRsZXIkMS5ub3RpZnkoYXBpLl9tZXRhLm5hbWUpO1xuICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmVyaWZ5QXR0YWNobWVudChkaWdlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgcmVxID0gYXR0YWNoU3RvcmUuZ2V0KGRpZ2VzdCk7XG4gICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUudGFyZ2V0LnJlc3VsdCkge1xuICAgICAgICB2YXIgZXJyID0gY3JlYXRlRXJyb3IoTUlTU0lOR19TVFVCLFxuICAgICAgICAgICd1bmtub3duIHN0dWIgYXR0YWNobWVudCB3aXRoIGRpZ2VzdCAnICtcbiAgICAgICAgICBkaWdlc3QpO1xuICAgICAgICBlcnIuc3RhdHVzID0gNDEyO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdmVyaWZ5QXR0YWNobWVudHMoZmluaXNoKSB7XG5cblxuICAgIHZhciBkaWdlc3RzID0gW107XG4gICAgZG9jSW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jSW5mbykge1xuICAgICAgaWYgKGRvY0luZm8uZGF0YSAmJiBkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgICAgdmFyIGF0dCA9IGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHNbZmlsZW5hbWVdO1xuICAgICAgICAgIGlmIChhdHQuc3R1Yikge1xuICAgICAgICAgICAgZGlnZXN0cy5wdXNoKGF0dC5kaWdlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFkaWdlc3RzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgIH1cbiAgICB2YXIgbnVtRG9uZSA9IDA7XG4gICAgdmFyIGVycjtcblxuICAgIGZ1bmN0aW9uIGNoZWNrRG9uZSgpIHtcbiAgICAgIGlmICgrK251bURvbmUgPT09IGRpZ2VzdHMubGVuZ3RoKSB7XG4gICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBkaWdlc3RzLmZvckVhY2goZnVuY3Rpb24gKGRpZ2VzdCkge1xuICAgICAgdmVyaWZ5QXR0YWNobWVudChkaWdlc3QsIGZ1bmN0aW9uIChhdHRFcnIpIHtcbiAgICAgICAgaWYgKGF0dEVyciAmJiAhZXJyKSB7XG4gICAgICAgICAgZXJyID0gYXR0RXJyO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZURvYyhkb2NJbmZvLCB3aW5uaW5nUmV2JCQxLCB3aW5uaW5nUmV2SXNEZWxldGVkLCBuZXdSZXZJc0RlbGV0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGlzVXBkYXRlLCBkZWx0YSwgcmVzdWx0c0lkeCwgY2FsbGJhY2spIHtcblxuICAgIGRvY0luZm8ubWV0YWRhdGEud2lubmluZ1JldiA9IHdpbm5pbmdSZXYkJDE7XG4gICAgZG9jSW5mby5tZXRhZGF0YS5kZWxldGVkID0gd2lubmluZ1JldklzRGVsZXRlZDtcblxuICAgIHZhciBkb2MgPSBkb2NJbmZvLmRhdGE7XG4gICAgZG9jLl9pZCA9IGRvY0luZm8ubWV0YWRhdGEuaWQ7XG4gICAgZG9jLl9yZXYgPSBkb2NJbmZvLm1ldGFkYXRhLnJldjtcblxuICAgIGlmIChuZXdSZXZJc0RlbGV0ZWQpIHtcbiAgICAgIGRvYy5fZGVsZXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGhhc0F0dGFjaG1lbnRzID0gZG9jLl9hdHRhY2htZW50cyAmJlxuICAgICAgT2JqZWN0LmtleXMoZG9jLl9hdHRhY2htZW50cykubGVuZ3RoO1xuICAgIGlmIChoYXNBdHRhY2htZW50cykge1xuICAgICAgcmV0dXJuIHdyaXRlQXR0YWNobWVudHMoZG9jSW5mbywgd2lubmluZ1JldiQkMSwgd2lubmluZ1JldklzRGVsZXRlZCxcbiAgICAgICAgaXNVcGRhdGUsIHJlc3VsdHNJZHgsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBkb2NDb3VudERlbHRhICs9IGRlbHRhO1xuICAgIHVwZGF0ZURvY0NvdW50SWZSZWFkeSgpO1xuXG4gICAgZmluaXNoRG9jKGRvY0luZm8sIHdpbm5pbmdSZXYkJDEsIHdpbm5pbmdSZXZJc0RlbGV0ZWQsXG4gICAgICBpc1VwZGF0ZSwgcmVzdWx0c0lkeCwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoRG9jKGRvY0luZm8sIHdpbm5pbmdSZXYkJDEsIHdpbm5pbmdSZXZJc0RlbGV0ZWQsXG4gICAgICAgICAgICAgICAgICAgICBpc1VwZGF0ZSwgcmVzdWx0c0lkeCwgY2FsbGJhY2spIHtcblxuICAgIHZhciBkb2MgPSBkb2NJbmZvLmRhdGE7XG4gICAgdmFyIG1ldGFkYXRhID0gZG9jSW5mby5tZXRhZGF0YTtcblxuICAgIGRvYy5fZG9jX2lkX3JldiA9IG1ldGFkYXRhLmlkICsgJzo6JyArIG1ldGFkYXRhLnJldjtcbiAgICBkZWxldGUgZG9jLl9pZDtcbiAgICBkZWxldGUgZG9jLl9yZXY7XG5cbiAgICBmdW5jdGlvbiBhZnRlclB1dERvYyhlKSB7XG4gICAgICB2YXIgcmV2c1RvRGVsZXRlID0gZG9jSW5mby5zdGVtbWVkUmV2cyB8fCBbXTtcblxuICAgICAgaWYgKGlzVXBkYXRlICYmIGFwaS5hdXRvX2NvbXBhY3Rpb24pIHtcbiAgICAgICAgcmV2c1RvRGVsZXRlID0gcmV2c1RvRGVsZXRlLmNvbmNhdChjb21wYWN0VHJlZShkb2NJbmZvLm1ldGFkYXRhKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXZzVG9EZWxldGUgJiYgcmV2c1RvRGVsZXRlLmxlbmd0aCkge1xuICAgICAgICBjb21wYWN0UmV2cyhyZXZzVG9EZWxldGUsIGRvY0luZm8ubWV0YWRhdGEuaWQsIHR4bik7XG4gICAgICB9XG5cbiAgICAgIG1ldGFkYXRhLnNlcSA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgIC8vIEN1cnJlbnQgX3JldiBpcyBjYWxjdWxhdGVkIGZyb20gX3Jldl90cmVlIG9uIHJlYWRcbiAgICAgIC8vIGRlbGV0ZSBtZXRhZGF0YS5yZXY7XG4gICAgICB2YXIgbWV0YWRhdGFUb1N0b3JlID0gZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEsIHdpbm5pbmdSZXYkJDEsXG4gICAgICAgIHdpbm5pbmdSZXZJc0RlbGV0ZWQpO1xuICAgICAgdmFyIG1ldGFEYXRhUmVxID0gZG9jU3RvcmUucHV0KG1ldGFkYXRhVG9TdG9yZSk7XG4gICAgICBtZXRhRGF0YVJlcS5vbnN1Y2Nlc3MgPSBhZnRlclB1dE1ldGFkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFmdGVyUHV0RG9jRXJyb3IoZSkge1xuICAgICAgLy8gQ29uc3RyYWludEVycm9yLCBuZWVkIHRvIHVwZGF0ZSwgbm90IHB1dCAoc2VlICMxNjM4IGZvciBkZXRhaWxzKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBhdm9pZCB0cmFuc2FjdGlvbiBhYm9ydFxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gYXZvaWQgdHJhbnNhY3Rpb24gb25lcnJvclxuICAgICAgdmFyIGluZGV4ID0gYnlTZXFTdG9yZS5pbmRleCgnX2RvY19pZF9yZXYnKTtcbiAgICAgIHZhciBnZXRLZXlSZXEgPSBpbmRleC5nZXRLZXkoZG9jLl9kb2NfaWRfcmV2KTtcbiAgICAgIGdldEtleVJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcHV0UmVxID0gYnlTZXFTdG9yZS5wdXQoZG9jLCBlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICBwdXRSZXEub25zdWNjZXNzID0gYWZ0ZXJQdXREb2M7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFmdGVyUHV0TWV0YWRhdGEoKSB7XG4gICAgICByZXN1bHRzW3Jlc3VsdHNJZHhdID0ge1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgaWQ6IG1ldGFkYXRhLmlkLFxuICAgICAgICByZXY6IG1ldGFkYXRhLnJldlxuICAgICAgfTtcbiAgICAgIGZldGNoZWREb2NzLnNldChkb2NJbmZvLm1ldGFkYXRhLmlkLCBkb2NJbmZvLm1ldGFkYXRhKTtcbiAgICAgIGluc2VydEF0dGFjaG1lbnRNYXBwaW5ncyhkb2NJbmZvLCBtZXRhZGF0YS5zZXEsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB2YXIgcHV0UmVxID0gYnlTZXFTdG9yZS5wdXQoZG9jKTtcblxuICAgIHB1dFJlcS5vbnN1Y2Nlc3MgPSBhZnRlclB1dERvYztcbiAgICBwdXRSZXEub25lcnJvciA9IGFmdGVyUHV0RG9jRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUF0dGFjaG1lbnRzKGRvY0luZm8sIHdpbm5pbmdSZXYkJDEsIHdpbm5pbmdSZXZJc0RlbGV0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVcGRhdGUsIHJlc3VsdHNJZHgsIGNhbGxiYWNrKSB7XG5cblxuICAgIHZhciBkb2MgPSBkb2NJbmZvLmRhdGE7XG5cbiAgICB2YXIgbnVtRG9uZSA9IDA7XG4gICAgdmFyIGF0dGFjaG1lbnRzID0gT2JqZWN0LmtleXMoZG9jLl9hdHRhY2htZW50cyk7XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0UmVzdWx0cygpIHtcbiAgICAgIGlmIChudW1Eb25lID09PSBhdHRhY2htZW50cy5sZW5ndGgpIHtcbiAgICAgICAgZmluaXNoRG9jKGRvY0luZm8sIHdpbm5pbmdSZXYkJDEsIHdpbm5pbmdSZXZJc0RlbGV0ZWQsXG4gICAgICAgICAgaXNVcGRhdGUsIHJlc3VsdHNJZHgsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2htZW50U2F2ZWQoKSB7XG4gICAgICBudW1Eb25lKys7XG4gICAgICBjb2xsZWN0UmVzdWx0cygpO1xuICAgIH1cblxuICAgIGF0dGFjaG1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGF0dCA9IGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHNba2V5XTtcbiAgICAgIGlmICghYXR0LnN0dWIpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhdHQuZGF0YTtcbiAgICAgICAgZGVsZXRlIGF0dC5kYXRhO1xuICAgICAgICBhdHQucmV2cG9zID0gcGFyc2VJbnQod2lubmluZ1JldiQkMSwgMTApO1xuICAgICAgICB2YXIgZGlnZXN0ID0gYXR0LmRpZ2VzdDtcbiAgICAgICAgc2F2ZUF0dGFjaG1lbnQoZGlnZXN0LCBkYXRhLCBhdHRhY2htZW50U2F2ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtRG9uZSsrO1xuICAgICAgICBjb2xsZWN0UmVzdWx0cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gbWFwIHNlcXMgdG8gYXR0YWNobWVudCBkaWdlc3RzLCB3aGljaFxuICAvLyB3ZSB3aWxsIG5lZWQgbGF0ZXIgZHVyaW5nIGNvbXBhY3Rpb25cbiAgZnVuY3Rpb24gaW5zZXJ0QXR0YWNobWVudE1hcHBpbmdzKGRvY0luZm8sIHNlcSwgY2FsbGJhY2spIHtcblxuICAgIHZhciBhdHRzQWRkZWQgPSAwO1xuICAgIHZhciBhdHRzVG9BZGQgPSBPYmplY3Qua2V5cyhkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzIHx8IHt9KTtcblxuICAgIGlmICghYXR0c1RvQWRkLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tEb25lKCkge1xuICAgICAgaWYgKCsrYXR0c0FkZGVkID09PSBhdHRzVG9BZGQubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKGF0dCkge1xuICAgICAgdmFyIGRpZ2VzdCA9IGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHNbYXR0XS5kaWdlc3Q7XG4gICAgICB2YXIgcmVxID0gYXR0YWNoQW5kU2VxU3RvcmUucHV0KHtcbiAgICAgICAgc2VxOiBzZXEsXG4gICAgICAgIGRpZ2VzdFNlcTogZGlnZXN0ICsgJzo6JyArIHNlcVxuICAgICAgfSk7XG5cbiAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBjaGVja0RvbmU7XG4gICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIHRoaXMgY2FsbGJhY2sgaXMgZm9yIGEgY29uc3RhaW50IGVycm9yLCB3aGljaCB3ZSBpZ25vcmVcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGRvY2lkL3JldiBoYXMgYWxyZWFkeSBiZWVuIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICAvLyB0aGUgZGlnZXN0IChlLmcuIHdoZW4gbmV3X2VkaXRzID09IGZhbHNlKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIGF2b2lkIHRyYW5zYWN0aW9uIGFib3J0XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIGF2b2lkIHRyYW5zYWN0aW9uIG9uZXJyb3JcbiAgICAgICAgY2hlY2tEb25lKCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHNUb0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgYWRkKGF0dHNUb0FkZFtpXSk7IC8vIGRvIGluIHBhcmFsbGVsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2F2ZUF0dGFjaG1lbnQoZGlnZXN0LCBkYXRhLCBjYWxsYmFjaykge1xuXG5cbiAgICB2YXIgZ2V0S2V5UmVxID0gYXR0YWNoU3RvcmUuY291bnQoZGlnZXN0KTtcbiAgICBnZXRLZXlSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjb3VudCA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmIChjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTsgLy8gYWxyZWFkeSBleGlzdHNcbiAgICAgIH1cbiAgICAgIHZhciBuZXdBdHQgPSB7XG4gICAgICAgIGRpZ2VzdDogZGlnZXN0LFxuICAgICAgICBib2R5OiBkYXRhXG4gICAgICB9O1xuICAgICAgdmFyIHB1dFJlcSA9IGF0dGFjaFN0b3JlLnB1dChuZXdBdHQpO1xuICAgICAgcHV0UmVxLm9uc3VjY2VzcyA9IGNhbGxiYWNrO1xuICAgIH07XG4gIH1cbn1cblxuLy8gQWJzdHJhY3Rpb24gb3ZlciBJREJDdXJzb3IgYW5kIGdldEFsbCgpL2dldEFsbEtleXMoKSB0aGF0IGFsbG93cyB1cyB0byBiYXRjaCBvdXIgb3BlcmF0aW9uc1xuLy8gd2hpbGUgZmFsbGluZyBiYWNrIHRvIGEgbm9ybWFsIElEQkN1cnNvciBvcGVyYXRpb24gb24gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGdldEFsbCgpIG9yXG4vLyBnZXRBbGxLZXlzKCkuIFRoaXMgYWxsb3dzIGZvciBhIG11Y2ggZmFzdGVyIGltcGxlbWVudGF0aW9uIHRoYW4ganVzdCBzdHJhaWdodC11cCBjdXJzb3JzLCBiZWNhdXNlXG4vLyB3ZSdyZSBub3QgcHJvY2Vzc2luZyBlYWNoIGRvY3VtZW50IG9uZS1hdC1hLXRpbWUuXG5mdW5jdGlvbiBydW5CYXRjaGVkQ3Vyc29yKG9iamVjdFN0b3JlLCBrZXlSYW5nZSwgZGVzY2VuZGluZywgYmF0Y2hTaXplLCBvbkJhdGNoKSB7XG5cbiAgaWYgKGJhdGNoU2l6ZSA9PT0gLTEpIHtcbiAgICBiYXRjaFNpemUgPSAxMDAwO1xuICB9XG5cbiAgLy8gQmFpbCBvdXQgb2YgZ2V0QWxsKCkvZ2V0QWxsS2V5cygpIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gIC8vIDEpIGVpdGhlciBtZXRob2QgaXMgdW5zdXBwb3J0ZWQgLSB3ZSBuZWVkIGJvdGhcbiAgLy8gMikgYmF0Y2hTaXplIGlzIDEgKG1pZ2h0IGFzIHdlbGwgdXNlIElEQkN1cnNvcilcbiAgLy8gMykgZGVzY2VuZGluZyDigJMgbm8gcmVhbCB3YXkgdG8gZG8gdGhpcyB2aWEgZ2V0QWxsKCkvZ2V0QWxsS2V5cygpXG5cbiAgdmFyIHVzZUdldEFsbCA9IHR5cGVvZiBvYmplY3RTdG9yZS5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0U3RvcmUuZ2V0QWxsS2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGJhdGNoU2l6ZSA+IDEgJiYgIWRlc2NlbmRpbmc7XG5cbiAgdmFyIGtleXNCYXRjaDtcbiAgdmFyIHZhbHVlc0JhdGNoO1xuICB2YXIgcHNldWRvQ3Vyc29yO1xuXG4gIGZ1bmN0aW9uIG9uR2V0QWxsKGUpIHtcbiAgICB2YWx1ZXNCYXRjaCA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICBpZiAoa2V5c0JhdGNoKSB7XG4gICAgICBvbkJhdGNoKGtleXNCYXRjaCwgdmFsdWVzQmF0Y2gsIHBzZXVkb0N1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25HZXRBbGxLZXlzKGUpIHtcbiAgICBrZXlzQmF0Y2ggPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgaWYgKHZhbHVlc0JhdGNoKSB7XG4gICAgICBvbkJhdGNoKGtleXNCYXRjaCwgdmFsdWVzQmF0Y2gsIHBzZXVkb0N1cnNvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29udGludWVQc2V1ZG9DdXJzb3IoKSB7XG4gICAgaWYgKCFrZXlzQmF0Y2gubGVuZ3RoKSB7IC8vIG5vIG1vcmUgcmVzdWx0c1xuICAgICAgcmV0dXJuIG9uQmF0Y2goKTtcbiAgICB9XG4gICAgLy8gZmV0Y2ggbmV4dCBiYXRjaCwgZXhjbHVzaXZlIHN0YXJ0XG4gICAgdmFyIGxhc3RLZXkgPSBrZXlzQmF0Y2hba2V5c0JhdGNoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBuZXdLZXlSYW5nZTtcbiAgICBpZiAoa2V5UmFuZ2UgJiYga2V5UmFuZ2UudXBwZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld0tleVJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQobGFzdEtleSwga2V5UmFuZ2UudXBwZXIsXG4gICAgICAgICAgdHJ1ZSwga2V5UmFuZ2UudXBwZXJPcGVuKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gXCJEYXRhRXJyb3JcIiAmJiBlLmNvZGUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gb25CYXRjaCgpOyAvLyB3ZSdyZSBkb25lLCBzdGFydGtleSBhbmQgZW5ka2V5IGFyZSBlcXVhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0tleVJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChsYXN0S2V5LCB0cnVlKTtcbiAgICB9XG4gICAga2V5UmFuZ2UgPSBuZXdLZXlSYW5nZTtcbiAgICBrZXlzQmF0Y2ggPSBudWxsO1xuICAgIHZhbHVlc0JhdGNoID0gbnVsbDtcbiAgICBvYmplY3RTdG9yZS5nZXRBbGwoa2V5UmFuZ2UsIGJhdGNoU2l6ZSkub25zdWNjZXNzID0gb25HZXRBbGw7XG4gICAgb2JqZWN0U3RvcmUuZ2V0QWxsS2V5cyhrZXlSYW5nZSwgYmF0Y2hTaXplKS5vbnN1Y2Nlc3MgPSBvbkdldEFsbEtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBvbkN1cnNvcihlKSB7XG4gICAgdmFyIGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICBpZiAoIWN1cnNvcikgeyAvLyBkb25lXG4gICAgICByZXR1cm4gb25CYXRjaCgpO1xuICAgIH1cbiAgICAvLyByZWd1bGFyIElEQkN1cnNvciBhY3RzIGxpa2UgYSBiYXRjaCB3aGVyZSBiYXRjaCBzaXplIGlzIGFsd2F5cyAxXG4gICAgb25CYXRjaChbY3Vyc29yLmtleV0sIFtjdXJzb3IudmFsdWVdLCBjdXJzb3IpO1xuICB9XG5cbiAgaWYgKHVzZUdldEFsbCkge1xuICAgIHBzZXVkb0N1cnNvciA9IHtcImNvbnRpbnVlXCI6IGNvbnRpbnVlUHNldWRvQ3Vyc29yfTtcbiAgICBvYmplY3RTdG9yZS5nZXRBbGwoa2V5UmFuZ2UsIGJhdGNoU2l6ZSkub25zdWNjZXNzID0gb25HZXRBbGw7XG4gICAgb2JqZWN0U3RvcmUuZ2V0QWxsS2V5cyhrZXlSYW5nZSwgYmF0Y2hTaXplKS5vbnN1Y2Nlc3MgPSBvbkdldEFsbEtleXM7XG4gIH0gZWxzZSBpZiAoZGVzY2VuZGluZykge1xuICAgIG9iamVjdFN0b3JlLm9wZW5DdXJzb3Ioa2V5UmFuZ2UsICdwcmV2Jykub25zdWNjZXNzID0gb25DdXJzb3I7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0U3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZSkub25zdWNjZXNzID0gb25DdXJzb3I7XG4gIH1cbn1cblxuLy8gc2ltcGxlIHNoaW0gZm9yIG9iamVjdFN0b3JlLmdldEFsbCgpLCBmYWxsaW5nIGJhY2sgdG8gSURCQ3Vyc29yXG5mdW5jdGlvbiBnZXRBbGwob2JqZWN0U3RvcmUsIGtleVJhbmdlLCBvblN1Y2Nlc3MpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3RTdG9yZS5nZXRBbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB1c2UgbmF0aXZlIGdldEFsbFxuICAgIG9iamVjdFN0b3JlLmdldEFsbChrZXlSYW5nZSkub25zdWNjZXNzID0gb25TdWNjZXNzO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBmYWxsIGJhY2sgdG8gY3Vyc29yc1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgZnVuY3Rpb24gb25DdXJzb3IoZSkge1xuICAgIHZhciBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgaWYgKGN1cnNvcikge1xuICAgICAgdmFsdWVzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblN1Y2Nlc3Moe1xuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICByZXN1bHQ6IHZhbHVlc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBvYmplY3RTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlKS5vbnN1Y2Nlc3MgPSBvbkN1cnNvcjtcbn1cblxuZnVuY3Rpb24gYWxsRG9jc0tleXMoa2V5cywgZG9jU3RvcmUsIG9uQmF0Y2gpIHtcbiAgLy8gSXQncyBub3QgZ3VhcmFudGVkIHRvIGJlIHJldHVybmVkIGluIHJpZ2h0IG9yZGVyICBcbiAgdmFyIHZhbHVlc0JhdGNoID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgdmFyIGNvdW50ID0gMDtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgZG9jU3RvcmUuZ2V0KGtleSkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0LnJlc3VsdCkge1xuICAgICAgICB2YWx1ZXNCYXRjaFtpbmRleF0gPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQmF0Y2hbaW5kZXhdID0ge2tleToga2V5LCBlcnJvcjogJ25vdF9mb3VuZCd9O1xuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgb25CYXRjaChrZXlzLCB2YWx1ZXNCYXRjaCwge30pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlSYW5nZShzdGFydCwgZW5kLCBpbmNsdXNpdmVFbmQsIGtleSwgZGVzY2VuZGluZykge1xuICB0cnkge1xuICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS5ib3VuZChlbmQsIHN0YXJ0LCAhaW5jbHVzaXZlRW5kLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSURCS2V5UmFuZ2UuYm91bmQoc3RhcnQsIGVuZCwgZmFsc2UsICFpbmNsdXNpdmVFbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgIGlmIChkZXNjZW5kaW5nKSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKHN0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS5sb3dlckJvdW5kKHN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZCkge1xuICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQoZW5kLCAhaW5jbHVzaXZlRW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKGVuZCwgIWluY2x1c2l2ZUVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgIHJldHVybiBJREJLZXlSYW5nZS5vbmx5KGtleSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlkYkFsbERvY3Mob3B0cywgaWRiLCBjYWxsYmFjaykge1xuICB2YXIgc3RhcnQgPSAnc3RhcnRrZXknIGluIG9wdHMgPyBvcHRzLnN0YXJ0a2V5IDogZmFsc2U7XG4gIHZhciBlbmQgPSAnZW5ka2V5JyBpbiBvcHRzID8gb3B0cy5lbmRrZXkgOiBmYWxzZTtcbiAgdmFyIGtleSA9ICdrZXknIGluIG9wdHMgPyBvcHRzLmtleSA6IGZhbHNlO1xuICB2YXIga2V5cyA9ICdrZXlzJyBpbiBvcHRzID8gb3B0cy5rZXlzIDogZmFsc2U7IFxuICB2YXIgc2tpcCA9IG9wdHMuc2tpcCB8fCAwO1xuICB2YXIgbGltaXQgPSB0eXBlb2Ygb3B0cy5saW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLmxpbWl0IDogLTE7XG4gIHZhciBpbmNsdXNpdmVFbmQgPSBvcHRzLmluY2x1c2l2ZV9lbmQgIT09IGZhbHNlO1xuXG4gIHZhciBrZXlSYW5nZSA7IFxuICB2YXIga2V5UmFuZ2VFcnJvcjtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5UmFuZ2UgPSBjcmVhdGVLZXlSYW5nZShzdGFydCwgZW5kLCBpbmNsdXNpdmVFbmQsIGtleSwgb3B0cy5kZXNjZW5kaW5nKTtcbiAgICBrZXlSYW5nZUVycm9yID0ga2V5UmFuZ2UgJiYga2V5UmFuZ2UuZXJyb3I7XG4gICAgaWYgKGtleVJhbmdlRXJyb3IgJiYgXG4gICAgICAhKGtleVJhbmdlRXJyb3IubmFtZSA9PT0gXCJEYXRhRXJyb3JcIiAmJiBrZXlSYW5nZUVycm9yLmNvZGUgPT09IDApKSB7XG4gICAgICAvLyBEYXRhRXJyb3Igd2l0aCBlcnJvciBjb2RlIDAgaW5kaWNhdGVzIHN0YXJ0IGlzIGxlc3MgdGhhbiBlbmQsIHNvXG4gICAgICAvLyBjYW4ganVzdCBkbyBhbiBlbXB0eSBxdWVyeS4gRWxzZSBuZWVkIHRvIHRocm93XG4gICAgICByZXR1cm4gY2FsbGJhY2soY3JlYXRlRXJyb3IoSURCX0VSUk9SLFxuICAgICAgICBrZXlSYW5nZUVycm9yLm5hbWUsIGtleVJhbmdlRXJyb3IubWVzc2FnZSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdG9yZXMgPSBbRE9DX1NUT1JFLCBCWV9TRVFfU1RPUkUsIE1FVEFfU1RPUkVdO1xuXG4gIGlmIChvcHRzLmF0dGFjaG1lbnRzKSB7XG4gICAgc3RvcmVzLnB1c2goQVRUQUNIX1NUT1JFKTtcbiAgfVxuICB2YXIgdHhuUmVzdWx0ID0gb3BlblRyYW5zYWN0aW9uU2FmZWx5KGlkYiwgc3RvcmVzLCAncmVhZG9ubHknKTtcbiAgaWYgKHR4blJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayh0eG5SZXN1bHQuZXJyb3IpO1xuICB9XG4gIHZhciB0eG4gPSB0eG5SZXN1bHQudHhuO1xuICB0eG4ub25jb21wbGV0ZSA9IG9uVHhuQ29tcGxldGU7XG4gIHR4bi5vbmFib3J0ID0gaWRiRXJyb3IoY2FsbGJhY2spO1xuICB2YXIgZG9jU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcbiAgdmFyIHNlcVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEJZX1NFUV9TVE9SRSk7XG4gIHZhciBtZXRhU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoTUVUQV9TVE9SRSk7XG4gIHZhciBkb2NJZFJldkluZGV4ID0gc2VxU3RvcmUuaW5kZXgoJ19kb2NfaWRfcmV2Jyk7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBkb2NDb3VudDtcbiAgdmFyIHVwZGF0ZVNlcTtcblxuICBtZXRhU3RvcmUuZ2V0KE1FVEFfU1RPUkUpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZG9jQ291bnQgPSBlLnRhcmdldC5yZXN1bHQuZG9jQ291bnQ7XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChvcHRzLnVwZGF0ZV9zZXEpIHtcbiAgICBnZXRNYXhVcGRhdGVTZXEoc2VxU3RvcmUsIGZ1bmN0aW9uIChlKSB7IFxuICAgICAgaWYgKGUudGFyZ2V0LnJlc3VsdCAmJiBlLnRhcmdldC5yZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICB1cGRhdGVTZXEgPSBlLnRhcmdldC5yZXN1bHRbMF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYXhVcGRhdGVTZXEob2JqZWN0U3RvcmUsIG9uU3VjY2Vzcykge1xuICAgIGZ1bmN0aW9uIG9uQ3Vyc29yKGUpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICB2YXIgbWF4S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGN1cnNvciAmJiBjdXJzb3Iua2V5KSB7XG4gICAgICAgIG1heEtleSA9IGN1cnNvci5rZXk7XG4gICAgICB9IFxuICAgICAgcmV0dXJuIG9uU3VjY2Vzcyh7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIHJlc3VsdDogW21heEtleV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IobnVsbCwgJ3ByZXYnKS5vbnN1Y2Nlc3MgPSBvbkN1cnNvcjtcbiAgfVxuXG4gIC8vIGlmIHRoZSB1c2VyIHNwZWNpZmllcyBpbmNsdWRlX2RvY3M9dHJ1ZSwgdGhlbiB3ZSBkb24ndFxuICAvLyB3YW50IHRvIGJsb2NrIHRoZSBtYWluIGN1cnNvciB3aGlsZSB3ZSdyZSBmZXRjaGluZyB0aGUgZG9jXG4gIGZ1bmN0aW9uIGZldGNoRG9jQXN5bmNocm9ub3VzbHkobWV0YWRhdGEsIHJvdywgd2lubmluZ1JldiQkMSkge1xuICAgIHZhciBrZXkgPSBtZXRhZGF0YS5pZCArIFwiOjpcIiArIHdpbm5pbmdSZXYkJDE7XG4gICAgZG9jSWRSZXZJbmRleC5nZXQoa2V5KS5vbnN1Y2Nlc3MgPSAgZnVuY3Rpb24gb25HZXREb2MoZSkge1xuICAgICAgcm93LmRvYyA9IGRlY29kZURvYyhlLnRhcmdldC5yZXN1bHQpIHx8IHt9O1xuICAgICAgaWYgKG9wdHMuY29uZmxpY3RzKSB7XG4gICAgICAgIHZhciBjb25mbGljdHMgPSBjb2xsZWN0Q29uZmxpY3RzKG1ldGFkYXRhKTtcbiAgICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3cuZG9jLl9jb25mbGljdHMgPSBjb25mbGljdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZldGNoQXR0YWNobWVudHNJZk5lY2Vzc2FyeShyb3cuZG9jLCBvcHRzLCB0eG4pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhbGxEb2NzSW5uZXIod2lubmluZ1JldiQkMSwgbWV0YWRhdGEpIHtcbiAgICB2YXIgcm93ID0ge1xuICAgICAgaWQ6IG1ldGFkYXRhLmlkLFxuICAgICAga2V5OiBtZXRhZGF0YS5pZCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHJldjogd2lubmluZ1JldiQkMVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRlbGV0ZWQgPSBtZXRhZGF0YS5kZWxldGVkO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICBpZiAoa2V5cykge1xuICAgICAgICByZXN1bHRzLnB1c2gocm93KTtcbiAgICAgICAgLy8gZGVsZXRlZCBkb2NzIGFyZSBva2F5IHdpdGggXCJrZXlzXCIgcmVxdWVzdHNcbiAgICAgICAgcm93LnZhbHVlLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICByb3cuZG9jID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNraXAtLSA8PSAwKSB7XG4gICAgICByZXN1bHRzLnB1c2gocm93KTtcbiAgICAgIGlmIChvcHRzLmluY2x1ZGVfZG9jcykge1xuICAgICAgICBmZXRjaERvY0FzeW5jaHJvbm91c2x5KG1ldGFkYXRhLCByb3csIHdpbm5pbmdSZXYkJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NCYXRjaChiYXRjaFZhbHVlcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBiYXRjaFZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSBsaW1pdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBiYXRjaFZhbHVlID0gYmF0Y2hWYWx1ZXNbaV07XG4gICAgICBpZiAoYmF0Y2hWYWx1ZS5lcnJvciAmJiBrZXlzKSB7XG4gICAgICAgIC8vIGtleSB3YXMgbm90IGZvdW5kIHdpdGggXCJrZXlzXCIgcmVxdWVzdHNcbiAgICAgICAgcmVzdWx0cy5wdXNoKGJhdGNoVmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtZXRhZGF0YSA9IGRlY29kZU1ldGFkYXRhKGJhdGNoVmFsdWUpO1xuICAgICAgdmFyIHdpbm5pbmdSZXYkJDEgPSBtZXRhZGF0YS53aW5uaW5nUmV2O1xuICAgICAgYWxsRG9jc0lubmVyKHdpbm5pbmdSZXYkJDEsIG1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkJhdGNoKGJhdGNoS2V5cywgYmF0Y2hWYWx1ZXMsIGN1cnNvcikge1xuICAgIGlmICghY3Vyc29yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3NCYXRjaChiYXRjaFZhbHVlcyk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uR2V0QWxsKGUpIHtcbiAgICB2YXIgdmFsdWVzID0gZS50YXJnZXQucmVzdWx0O1xuICAgIGlmIChvcHRzLmRlc2NlbmRpbmcpIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHByb2Nlc3NCYXRjaCh2YWx1ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25SZXN1bHRzUmVhZHkoKSB7XG4gICAgdmFyIHJldHVyblZhbCA9IHtcbiAgICAgIHRvdGFsX3Jvd3M6IGRvY0NvdW50LFxuICAgICAgb2Zmc2V0OiBvcHRzLnNraXAsXG4gICAgICByb3dzOiByZXN1bHRzXG4gICAgfTtcbiAgICBcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob3B0cy51cGRhdGVfc2VxICYmIHVwZGF0ZVNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm5WYWwudXBkYXRlX3NlcSA9IHVwZGF0ZVNlcTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgcmV0dXJuVmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHhuQ29tcGxldGUoKSB7XG4gICAgaWYgKG9wdHMuYXR0YWNobWVudHMpIHtcbiAgICAgIHBvc3RQcm9jZXNzQXR0YWNobWVudHMocmVzdWx0cywgb3B0cy5iaW5hcnkpLnRoZW4ob25SZXN1bHRzUmVhZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblJlc3VsdHNSZWFkeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRvbid0IGJvdGhlciBkb2luZyBhbnkgcmVxdWVzdHMgaWYgc3RhcnQgPiBlbmQgb3IgbGltaXQgPT09IDBcbiAgaWYgKGtleVJhbmdlRXJyb3IgfHwgbGltaXQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGtleXMpIHtcbiAgICByZXR1cm4gYWxsRG9jc0tleXMob3B0cy5rZXlzLCBkb2NTdG9yZSwgb25CYXRjaCk7XG4gIH1cbiAgaWYgKGxpbWl0ID09PSAtMSkgeyAvLyBqdXN0IGZldGNoIGV2ZXJ5dGhpbmdcbiAgICByZXR1cm4gZ2V0QWxsKGRvY1N0b3JlLCBrZXlSYW5nZSwgb25HZXRBbGwpO1xuICB9XG4gIC8vIGVsc2UgZG8gYSBjdXJzb3JcbiAgLy8gY2hvb3NlIGEgYmF0Y2ggc2l6ZSBiYXNlZCBvbiB0aGUgc2tpcCwgc2luY2Ugd2UnbGwgbmVlZCB0byBza2lwIHRoYXQgbWFueVxuICBydW5CYXRjaGVkQ3Vyc29yKGRvY1N0b3JlLCBrZXlSYW5nZSwgb3B0cy5kZXNjZW5kaW5nLCBsaW1pdCArIHNraXAsIG9uQmF0Y2gpO1xufVxuXG4vL1xuLy8gQmxvYnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIHZlcnNpb25zIG9mIEluZGV4ZWREQiwgbm90YWJseVxuLy8gQ2hyb21lIDwzNyBhbmQgQW5kcm9pZCA8NS4gSW4gdGhvc2UgdmVyc2lvbnMsIHN0b3JpbmcgYSBibG9iIHdpbGwgdGhyb3cuXG4vL1xuLy8gVmFyaW91cyBvdGhlciBibG9iIGJ1Z3MgZXhpc3QgaW4gQ2hyb21lIHYzNy00MiAoaW5jbHVzaXZlKS5cbi8vIERldGVjdGluZyB0aGVtIGlzIGV4cGVuc2l2ZSBhbmQgY29uZnVzaW5nIHRvIHVzZXJzLCBhbmQgQ2hyb21lIDM3LTQyXG4vLyBpcyBhdCB2ZXJ5IGxvdyB1c2FnZSB3b3JsZHdpZGUsIHNvIHdlIGRvIGEgaGFja3kgdXNlckFnZW50IGNoZWNrIGluc3RlYWQuXG4vL1xuLy8gY29udGVudC10eXBlIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQwODEyMFxuLy8gNDA0IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzkxNlxuLy8gRmlsZVJlYWRlciBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc4MzZcbi8vXG5mdW5jdGlvbiBjaGVja0Jsb2JTdXBwb3J0KHR4bikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICB2YXIgYmxvYiQkMSA9IGJsb2IoWycnXSk7XG4gICAgdmFyIHJlcSA9IHR4bi5vYmplY3RTdG9yZShERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFKS5wdXQoYmxvYiQkMSwgJ2tleScpO1xuXG4gICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXRjaGVkQ2hyb21lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgICB2YXIgbWF0Y2hlZEVkZ2UgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvLyk7XG4gICAgICAvLyBNUyBFZGdlIHByZXRlbmRzIHRvIGJlIENocm9tZSA0MjpcbiAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4NjkzMDElMjh2PXZzLjg1JTI5LmFzcHhcbiAgICAgIHJlc29sdmUobWF0Y2hlZEVkZ2UgfHwgIW1hdGNoZWRDaHJvbWUgfHxcbiAgICAgICAgcGFyc2VJbnQobWF0Y2hlZENocm9tZVsxXSwgMTApID49IDQzKTtcbiAgICB9O1xuXG4gICAgcmVxLm9uZXJyb3IgPSB0eG4ub25hYm9ydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gYWJvcnRzIG5vdyBpdHMgZHVlIHRvIG5vdCBiZWluZyBhYmxlIHRvXG4gICAgICAvLyB3cml0ZSB0byB0aGUgZGF0YWJhc2UsIGxpa2VseSBkdWUgdG8gdGhlIGRpc2sgYmVpbmcgZnVsbFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH07XG4gIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIGVycm9yLCBzbyBhc3N1bWUgdW5zdXBwb3J0ZWRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvdW50RG9jcyh0eG4sIGNiKSB7XG4gIHZhciBpbmRleCA9IHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmluZGV4KCdkZWxldGVkT3JMb2NhbCcpO1xuICBpbmRleC5jb3VudChJREJLZXlSYW5nZS5vbmx5KCcwJykpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgY2IoZS50YXJnZXQucmVzdWx0KTtcbiAgfTtcbn1cblxuLy8gVGhpcyB0YXNrIHF1ZXVlIGVuc3VyZXMgdGhhdCBJREIgb3BlbiBjYWxscyBhcmUgZG9uZSBpbiB0aGVpciBvd24gdGlja1xuXG52YXIgcnVubmluZyA9IGZhbHNlO1xudmFyIHF1ZXVlID0gW107XG5cbmZ1bmN0aW9uIHRyeUNvZGUoZnVuLCBlcnIsIHJlcywgUG91Y2hEQikge1xuICB0cnkge1xuICAgIGZ1bihlcnIsIHJlcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFNob3VsZG4ndCBoYXBwZW4sIGJ1dCBpbiBzb21lIG9kZCBjYXNlc1xuICAgIC8vIEluZGV4ZWREQiBpbXBsZW1lbnRhdGlvbnMgbWlnaHQgdGhyb3cgYSBzeW5jXG4gICAgLy8gZXJyb3IsIGluIHdoaWNoIGNhc2UgdGhpcyB3aWxsIGF0IGxlYXN0IGxvZyBpdC5cbiAgICBQb3VjaERCLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5leHQoKSB7XG4gIGlmIChydW5uaW5nIHx8ICFxdWV1ZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcnVubmluZyA9IHRydWU7XG4gIHF1ZXVlLnNoaWZ0KCkoKTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVRhc2soYWN0aW9uLCBjYWxsYmFjaywgUG91Y2hEQikge1xuICBxdWV1ZS5wdXNoKGZ1bmN0aW9uIHJ1bkFjdGlvbigpIHtcbiAgICBhY3Rpb24oZnVuY3Rpb24gcnVuQ2FsbGJhY2soZXJyLCByZXMpIHtcbiAgICAgIHRyeUNvZGUoY2FsbGJhY2ssIGVyciwgcmVzLCBQb3VjaERCKTtcbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIG5leHRUaWNrKGZ1bmN0aW9uIHJ1bk5leHQoKSB7XG4gICAgICAgIGFwcGx5TmV4dChQb3VjaERCKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgYXBwbHlOZXh0KCk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZXMob3B0cywgYXBpLCBkYk5hbWUsIGlkYikge1xuICBvcHRzID0gY2xvbmUob3B0cyk7XG5cbiAgaWYgKG9wdHMuY29udGludW91cykge1xuICAgIHZhciBpZCA9IGRiTmFtZSArICc6JyArIHV1aWQoKTtcbiAgICBjaGFuZ2VzSGFuZGxlciQxLmFkZExpc3RlbmVyKGRiTmFtZSwgaWQsIGFwaSwgb3B0cyk7XG4gICAgY2hhbmdlc0hhbmRsZXIkMS5ub3RpZnkoZGJOYW1lKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5nZXNIYW5kbGVyJDEucmVtb3ZlTGlzdGVuZXIoZGJOYW1lLCBpZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBkb2NJZHMgPSBvcHRzLmRvY19pZHMgJiYgbmV3IFNldChvcHRzLmRvY19pZHMpO1xuXG4gIG9wdHMuc2luY2UgPSBvcHRzLnNpbmNlIHx8IDA7XG4gIHZhciBsYXN0U2VxID0gb3B0cy5zaW5jZTtcblxuICB2YXIgbGltaXQgPSAnbGltaXQnIGluIG9wdHMgPyBvcHRzLmxpbWl0IDogLTE7XG4gIGlmIChsaW1pdCA9PT0gMCkge1xuICAgIGxpbWl0ID0gMTsgLy8gcGVyIENvdWNoREIgX2NoYW5nZXMgc3BlY1xuICB9XG5cbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIG51bVJlc3VsdHMgPSAwO1xuICB2YXIgZmlsdGVyID0gZmlsdGVyQ2hhbmdlKG9wdHMpO1xuICB2YXIgZG9jSWRzVG9NZXRhZGF0YSA9IG5ldyBNYXAoKTtcblxuICB2YXIgdHhuO1xuICB2YXIgYnlTZXFTdG9yZTtcbiAgdmFyIGRvY1N0b3JlO1xuICB2YXIgZG9jSWRSZXZJbmRleDtcblxuICBmdW5jdGlvbiBvbkJhdGNoKGJhdGNoS2V5cywgYmF0Y2hWYWx1ZXMsIGN1cnNvcikge1xuICAgIGlmICghY3Vyc29yIHx8ICFiYXRjaEtleXMubGVuZ3RoKSB7IC8vIGRvbmVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2lubmluZ0RvY3MgPSBuZXcgQXJyYXkoYmF0Y2hLZXlzLmxlbmd0aCk7XG4gICAgdmFyIG1ldGFkYXRhcyA9IG5ldyBBcnJheShiYXRjaEtleXMubGVuZ3RoKTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNZXRhZGF0YUFuZFdpbm5pbmdEb2MobWV0YWRhdGEsIHdpbm5pbmdEb2MpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBvcHRzLnByb2Nlc3NDaGFuZ2Uod2lubmluZ0RvYywgbWV0YWRhdGEsIG9wdHMpO1xuICAgICAgbGFzdFNlcSA9IGNoYW5nZS5zZXEgPSBtZXRhZGF0YS5zZXE7XG5cbiAgICAgIHZhciBmaWx0ZXJlZCA9IGZpbHRlcihjaGFuZ2UpO1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJlZCA9PT0gJ29iamVjdCcpIHsgLy8gYW55dGhpbmcgYnV0IHRydWUvZmFsc2UgaW5kaWNhdGVzIGVycm9yXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChmaWx0ZXJlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZmlsdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgbnVtUmVzdWx0cysrO1xuICAgICAgaWYgKG9wdHMucmV0dXJuX2RvY3MpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGNoYW5nZSk7XG4gICAgICB9XG4gICAgICAvLyBwcm9jZXNzIHRoZSBhdHRhY2htZW50IGltbWVkaWF0ZWx5XG4gICAgICAvLyBmb3IgdGhlIGJlbmVmaXQgb2YgbGl2ZSBsaXN0ZW5lcnNcbiAgICAgIGlmIChvcHRzLmF0dGFjaG1lbnRzICYmIG9wdHMuaW5jbHVkZV9kb2NzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGZldGNoQXR0YWNobWVudHNJZk5lY2Vzc2FyeSh3aW5uaW5nRG9jLCBvcHRzLCB0eG4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBvc3RQcm9jZXNzQXR0YWNobWVudHMoW2NoYW5nZV0sIG9wdHMuYmluYXJ5KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShjaGFuZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGFuZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQmF0Y2hEb25lKCkge1xuICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd2lubmluZ0RvY3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG51bVJlc3VsdHMgPT09IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbm5pbmdEb2MgPSB3aW5uaW5nRG9jc1tpXTtcbiAgICAgICAgaWYgKCF3aW5uaW5nRG9jKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gbWV0YWRhdGFzW2ldO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHByb2Nlc3NNZXRhZGF0YUFuZFdpbm5pbmdEb2MobWV0YWRhdGEsIHdpbm5pbmdEb2MpKTtcbiAgICAgIH1cblxuICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2hhbmdlc1tpXSkge1xuICAgICAgICAgICAgb3B0cy5vbkNoYW5nZShjaGFuZ2VzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKG9wdHMuY29tcGxldGUpO1xuXG4gICAgICBpZiAobnVtUmVzdWx0cyAhPT0gbGltaXQpIHtcbiAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggYWxsIG1ldGFkYXRhcy93aW5uaW5nZG9jcyBmcm9tIHRoaXMgYmF0Y2ggaW4gcGFyYWxsZWwsIHRoZW4gcHJvY2Vzc1xuICAgIC8vIHRoZW0gYWxsIG9ubHkgb25jZSBhbGwgZGF0YSBoYXMgYmVlbiBjb2xsZWN0ZWQuIFRoaXMgaXMgZG9uZSBpbiBwYXJhbGxlbFxuICAgIC8vIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkb2luZyBpdCBvbmUtYXQtYS10aW1lLlxuICAgIHZhciBudW1Eb25lID0gMDtcbiAgICBiYXRjaFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgdmFyIGRvYyA9IGRlY29kZURvYyh2YWx1ZSk7XG4gICAgICB2YXIgc2VxID0gYmF0Y2hLZXlzW2ldO1xuICAgICAgZmV0Y2hXaW5uaW5nRG9jQW5kTWV0YWRhdGEoZG9jLCBzZXEsIGZ1bmN0aW9uIChtZXRhZGF0YSwgd2lubmluZ0RvYykge1xuICAgICAgICBtZXRhZGF0YXNbaV0gPSBtZXRhZGF0YTtcbiAgICAgICAgd2lubmluZ0RvY3NbaV0gPSB3aW5uaW5nRG9jO1xuICAgICAgICBpZiAoKytudW1Eb25lID09PSBiYXRjaEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgb25CYXRjaERvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkdldE1ldGFkYXRhKGRvYywgc2VxLCBtZXRhZGF0YSwgY2IpIHtcbiAgICBpZiAobWV0YWRhdGEuc2VxICE9PSBzZXEpIHtcbiAgICAgIC8vIHNvbWUgb3RoZXIgc2VxIGlzIGxhdGVyXG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9XG5cbiAgICBpZiAobWV0YWRhdGEud2lubmluZ1JldiA9PT0gZG9jLl9yZXYpIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIHdpbm5pbmcgZG9jXG4gICAgICByZXR1cm4gY2IobWV0YWRhdGEsIGRvYyk7XG4gICAgfVxuXG4gICAgLy8gZmV0Y2ggd2lubmluZyBkb2MgaW4gc2VwYXJhdGUgcmVxdWVzdFxuICAgIHZhciBkb2NJZFJldiA9IGRvYy5faWQgKyAnOjonICsgbWV0YWRhdGEud2lubmluZ1JldjtcbiAgICB2YXIgcmVxID0gZG9jSWRSZXZJbmRleC5nZXQoZG9jSWRSZXYpO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgY2IobWV0YWRhdGEsIGRlY29kZURvYyhlLnRhcmdldC5yZXN1bHQpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hXaW5uaW5nRG9jQW5kTWV0YWRhdGEoZG9jLCBzZXEsIGNiKSB7XG4gICAgaWYgKGRvY0lkcyAmJiAhZG9jSWRzLmhhcyhkb2MuX2lkKSkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfVxuXG4gICAgdmFyIG1ldGFkYXRhID0gZG9jSWRzVG9NZXRhZGF0YS5nZXQoZG9jLl9pZCk7XG4gICAgaWYgKG1ldGFkYXRhKSB7IC8vIGNhY2hlZFxuICAgICAgcmV0dXJuIG9uR2V0TWV0YWRhdGEoZG9jLCBzZXEsIG1ldGFkYXRhLCBjYik7XG4gICAgfVxuICAgIC8vIG1ldGFkYXRhIG5vdCBjYWNoZWQsIGhhdmUgdG8gZ28gZmV0Y2ggaXRcbiAgICBkb2NTdG9yZS5nZXQoZG9jLl9pZCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIG1ldGFkYXRhID0gZGVjb2RlTWV0YWRhdGEoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgIGRvY0lkc1RvTWV0YWRhdGEuc2V0KGRvYy5faWQsIG1ldGFkYXRhKTtcbiAgICAgIG9uR2V0TWV0YWRhdGEoZG9jLCBzZXEsIG1ldGFkYXRhLCBjYik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICBvcHRzLmNvbXBsZXRlKG51bGwsIHtcbiAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICBsYXN0X3NlcTogbGFzdFNlcVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UeG5Db21wbGV0ZSgpIHtcbiAgICBpZiAoIW9wdHMuY29udGludW91cyAmJiBvcHRzLmF0dGFjaG1lbnRzKSB7XG4gICAgICAvLyBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgcG9zdFByb2Nlc3Npbmcgd2FzIGFscmVhZHkgZG9uZSxcbiAgICAgIC8vIHNvIGRvIGl0IGFnYWluXG4gICAgICBwb3N0UHJvY2Vzc0F0dGFjaG1lbnRzKHJlc3VsdHMpLnRoZW4oZmluaXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9iamVjdFN0b3JlcyA9IFtET0NfU1RPUkUsIEJZX1NFUV9TVE9SRV07XG4gIGlmIChvcHRzLmF0dGFjaG1lbnRzKSB7XG4gICAgb2JqZWN0U3RvcmVzLnB1c2goQVRUQUNIX1NUT1JFKTtcbiAgfVxuICB2YXIgdHhuUmVzdWx0ID0gb3BlblRyYW5zYWN0aW9uU2FmZWx5KGlkYiwgb2JqZWN0U3RvcmVzLCAncmVhZG9ubHknKTtcbiAgaWYgKHR4blJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiBvcHRzLmNvbXBsZXRlKHR4blJlc3VsdC5lcnJvcik7XG4gIH1cbiAgdHhuID0gdHhuUmVzdWx0LnR4bjtcbiAgdHhuLm9uYWJvcnQgPSBpZGJFcnJvcihvcHRzLmNvbXBsZXRlKTtcbiAgdHhuLm9uY29tcGxldGUgPSBvblR4bkNvbXBsZXRlO1xuXG4gIGJ5U2VxU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFKTtcbiAgZG9jU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcbiAgZG9jSWRSZXZJbmRleCA9IGJ5U2VxU3RvcmUuaW5kZXgoJ19kb2NfaWRfcmV2Jyk7XG5cbiAgdmFyIGtleVJhbmdlID0gKG9wdHMuc2luY2UgJiYgIW9wdHMuZGVzY2VuZGluZykgP1xuICAgIElEQktleVJhbmdlLmxvd2VyQm91bmQob3B0cy5zaW5jZSwgdHJ1ZSkgOiBudWxsO1xuXG4gIHJ1bkJhdGNoZWRDdXJzb3IoYnlTZXFTdG9yZSwga2V5UmFuZ2UsIG9wdHMuZGVzY2VuZGluZywgbGltaXQsIG9uQmF0Y2gpO1xufVxuXG52YXIgY2FjaGVkREJzID0gbmV3IE1hcCgpO1xudmFyIGJsb2JTdXBwb3J0UHJvbWlzZTtcbnZhciBvcGVuUmVxTGlzdCA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gSWRiUG91Y2gob3B0cywgY2FsbGJhY2spIHtcbiAgdmFyIGFwaSA9IHRoaXM7XG5cbiAgZW5xdWV1ZVRhc2soZnVuY3Rpb24gKHRoaXNDYWxsYmFjaykge1xuICAgIGluaXQoYXBpLCBvcHRzLCB0aGlzQ2FsbGJhY2spO1xuICB9LCBjYWxsYmFjaywgYXBpLmNvbnN0cnVjdG9yKTtcbn1cblxuZnVuY3Rpb24gaW5pdChhcGksIG9wdHMsIGNhbGxiYWNrKSB7XG5cbiAgdmFyIGRiTmFtZSA9IG9wdHMubmFtZTtcblxuICB2YXIgaWRiID0gbnVsbDtcbiAgYXBpLl9tZXRhID0gbnVsbDtcblxuICAvLyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhIGZyZXNoIG5ldyBkYXRhYmFzZVxuICBmdW5jdGlvbiBjcmVhdGVTY2hlbWEoZGIpIHtcbiAgICB2YXIgZG9jU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShET0NfU1RPUkUsIHtrZXlQYXRoIDogJ2lkJ30pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKEJZX1NFUV9TVE9SRSwge2F1dG9JbmNyZW1lbnQ6IHRydWV9KVxuICAgICAgLmNyZWF0ZUluZGV4KCdfZG9jX2lkX3JldicsICdfZG9jX2lkX3JldicsIHt1bmlxdWU6IHRydWV9KTtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShBVFRBQ0hfU1RPUkUsIHtrZXlQYXRoOiAnZGlnZXN0J30pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKE1FVEFfU1RPUkUsIHtrZXlQYXRoOiAnaWQnLCBhdXRvSW5jcmVtZW50OiBmYWxzZX0pO1xuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpO1xuXG4gICAgLy8gYWRkZWQgaW4gdjJcbiAgICBkb2NTdG9yZS5jcmVhdGVJbmRleCgnZGVsZXRlZE9yTG9jYWwnLCAnZGVsZXRlZE9yTG9jYWwnLCB7dW5pcXVlIDogZmFsc2V9KTtcblxuICAgIC8vIGFkZGVkIGluIHYzXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoTE9DQUxfU1RPUkUsIHtrZXlQYXRoOiAnX2lkJ30pO1xuXG4gICAgLy8gYWRkZWQgaW4gdjRcbiAgICB2YXIgYXR0QW5kU2VxU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShBVFRBQ0hfQU5EX1NFUV9TVE9SRSxcbiAgICAgIHthdXRvSW5jcmVtZW50OiB0cnVlfSk7XG4gICAgYXR0QW5kU2VxU3RvcmUuY3JlYXRlSW5kZXgoJ3NlcScsICdzZXEnKTtcbiAgICBhdHRBbmRTZXFTdG9yZS5jcmVhdGVJbmRleCgnZGlnZXN0U2VxJywgJ2RpZ2VzdFNlcScsIHt1bmlxdWU6IHRydWV9KTtcbiAgfVxuXG4gIC8vIG1pZ3JhdGlvbiB0byB2ZXJzaW9uIDJcbiAgLy8gdW5mb3J0dW5hdGVseSBcImRlbGV0ZWRPckxvY2FsXCIgaXMgYSBtaXNub21lciBub3cgdGhhdCB3ZSBubyBsb25nZXJcbiAgLy8gc3RvcmUgbG9jYWwgZG9jcyBpbiB0aGUgbWFpbiBkb2Mtc3RvcmUsIGJ1dCB3aGFkZHlhZ29ubmFkb1xuICBmdW5jdGlvbiBhZGREZWxldGVkT3JMb2NhbEluZGV4KHR4biwgY2FsbGJhY2spIHtcbiAgICB2YXIgZG9jU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcbiAgICBkb2NTdG9yZS5jcmVhdGVJbmRleCgnZGVsZXRlZE9yTG9jYWwnLCAnZGVsZXRlZE9yTG9jYWwnLCB7dW5pcXVlIDogZmFsc2V9KTtcblxuICAgIGRvY1N0b3JlLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgIHZhciBkZWxldGVkID0gaXNEZWxldGVkKG1ldGFkYXRhKTtcbiAgICAgICAgbWV0YWRhdGEuZGVsZXRlZE9yTG9jYWwgPSBkZWxldGVkID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgZG9jU3RvcmUucHV0KG1ldGFkYXRhKTtcbiAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBtaWdyYXRpb24gdG8gdmVyc2lvbiAzIChwYXJ0IDEpXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsU3RvcmVTY2hlbWEoZGIpIHtcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShMT0NBTF9TVE9SRSwge2tleVBhdGg6ICdfaWQnfSlcbiAgICAgIC5jcmVhdGVJbmRleCgnX2RvY19pZF9yZXYnLCAnX2RvY19pZF9yZXYnLCB7dW5pcXVlOiB0cnVlfSk7XG4gIH1cblxuICAvLyBtaWdyYXRpb24gdG8gdmVyc2lvbiAzIChwYXJ0IDIpXG4gIGZ1bmN0aW9uIG1pZ3JhdGVMb2NhbFN0b3JlKHR4biwgY2IpIHtcbiAgICB2YXIgbG9jYWxTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShMT0NBTF9TVE9SRSk7XG4gICAgdmFyIGRvY1N0b3JlID0gdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSk7XG4gICAgdmFyIHNlcVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEJZX1NFUV9TVE9SRSk7XG5cbiAgICB2YXIgY3Vyc29yID0gZG9jU3RvcmUub3BlbkN1cnNvcigpO1xuICAgIGN1cnNvci5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgIHZhciBkb2NJZCA9IG1ldGFkYXRhLmlkO1xuICAgICAgICB2YXIgbG9jYWwgPSBpc0xvY2FsSWQkMShkb2NJZCk7XG4gICAgICAgIHZhciByZXYgPSB3aW5uaW5nUmV2KG1ldGFkYXRhKTtcbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgdmFyIGRvY0lkUmV2ID0gZG9jSWQgKyBcIjo6XCIgKyByZXY7XG4gICAgICAgICAgLy8gcmVtb3ZlIGFsbCBzZXEgZW50cmllc1xuICAgICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRvY0lkXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gZG9jSWQgKyBcIjo6XCI7XG4gICAgICAgICAgdmFyIGVuZCA9IGRvY0lkICsgXCI6On5cIjtcbiAgICAgICAgICB2YXIgaW5kZXggPSBzZXFTdG9yZS5pbmRleCgnX2RvY19pZF9yZXYnKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChzdGFydCwgZW5kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgIHZhciBzZXFDdXJzb3IgPSBpbmRleC5vcGVuQ3Vyc29yKHJhbmdlKTtcbiAgICAgICAgICBzZXFDdXJzb3Iub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNlcUN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmICghc2VxQ3Vyc29yKSB7XG4gICAgICAgICAgICAgIC8vIGRvbmVcbiAgICAgICAgICAgICAgZG9jU3RvcmUuZGVsZXRlKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcUN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuX2RvY19pZF9yZXYgPT09IGRvY0lkUmV2KSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZS5wdXQoZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VxU3RvcmUuZGVsZXRlKHNlcUN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgc2VxQ3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBtaWdyYXRpb24gdG8gdmVyc2lvbiA0IChwYXJ0IDEpXG4gIGZ1bmN0aW9uIGFkZEF0dGFjaEFuZFNlcVN0b3JlKGRiKSB7XG4gICAgdmFyIGF0dEFuZFNlcVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoQVRUQUNIX0FORF9TRVFfU1RPUkUsXG4gICAgICB7YXV0b0luY3JlbWVudDogdHJ1ZX0pO1xuICAgIGF0dEFuZFNlcVN0b3JlLmNyZWF0ZUluZGV4KCdzZXEnLCAnc2VxJyk7XG4gICAgYXR0QW5kU2VxU3RvcmUuY3JlYXRlSW5kZXgoJ2RpZ2VzdFNlcScsICdkaWdlc3RTZXEnLCB7dW5pcXVlOiB0cnVlfSk7XG4gIH1cblxuICAvLyBtaWdyYXRpb24gdG8gdmVyc2lvbiA0IChwYXJ0IDIpXG4gIGZ1bmN0aW9uIG1pZ3JhdGVBdHRzQW5kU2Vxcyh0eG4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlcVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEJZX1NFUV9TVE9SRSk7XG4gICAgdmFyIGF0dFN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEFUVEFDSF9TVE9SRSk7XG4gICAgdmFyIGF0dEFuZFNlcVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKEFUVEFDSF9BTkRfU0VRX1NUT1JFKTtcblxuICAgIC8vIG5lZWQgdG8gYWN0dWFsbHkgcG9wdWxhdGUgdGhlIHRhYmxlLiB0aGlzIGlzIHRoZSBleHBlbnNpdmUgcGFydCxcbiAgICAvLyBzbyBhcyBhbiBvcHRpbWl6YXRpb24sIGNoZWNrIGZpcnN0IHRoYXQgdGhpcyBkYXRhYmFzZSBldmVuXG4gICAgLy8gY29udGFpbnMgYXR0YWNobWVudHNcbiAgICB2YXIgcmVxID0gYXR0U3RvcmUuY291bnQoKTtcbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjb3VudCA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7IC8vIGRvbmVcbiAgICAgIH1cblxuICAgICAgc2VxU3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7IC8vIGRvbmVcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICB2YXIgc2VxID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgIHZhciBhdHRzID0gT2JqZWN0LmtleXMoZG9jLl9hdHRhY2htZW50cyB8fCB7fSk7XG4gICAgICAgIHZhciBkaWdlc3RNYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhdHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGF0dCA9IGRvYy5fYXR0YWNobWVudHNbYXR0c1tqXV07XG4gICAgICAgICAgZGlnZXN0TWFwW2F0dC5kaWdlc3RdID0gdHJ1ZTsgLy8gdW5pcSBkaWdlc3RzLCBqdXN0IGluIGNhc2VcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlnZXN0cyA9IE9iamVjdC5rZXlzKGRpZ2VzdE1hcCk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBkaWdlc3RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGRpZ2VzdCA9IGRpZ2VzdHNbal07XG4gICAgICAgICAgYXR0QW5kU2VxU3RvcmUucHV0KHtcbiAgICAgICAgICAgIHNlcTogc2VxLFxuICAgICAgICAgICAgZGlnZXN0U2VxOiBkaWdlc3QgKyAnOjonICsgc2VxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyBtaWdyYXRpb24gdG8gdmVyc2lvbiA1XG4gIC8vIEluc3RlYWQgb2YgcmVseWluZyBvbiBvbi10aGUtZmx5IG1pZ3JhdGlvbiBvZiBtZXRhZGF0YSxcbiAgLy8gdGhpcyBicmluZ3MgdGhlIGRvYy1zdG9yZSB0byBpdHMgbW9kZXJuIGZvcm06XG4gIC8vIC0gbWV0YWRhdGEud2lubmluZ3JldlxuICAvLyAtIG1ldGFkYXRhLnNlcVxuICAvLyAtIHN0cmluZ2lmeSB0aGUgbWV0YWRhdGEgd2hlbiBzdG9yaW5nIGl0XG4gIGZ1bmN0aW9uIG1pZ3JhdGVNZXRhZGF0YSh0eG4pIHtcblxuICAgIGZ1bmN0aW9uIGRlY29kZU1ldGFkYXRhQ29tcGF0KHN0b3JlZE9iamVjdCkge1xuICAgICAgaWYgKCFzdG9yZWRPYmplY3QuZGF0YSkge1xuICAgICAgICAvLyBvbGQgZm9ybWF0LCB3aGVuIHdlIGRpZG4ndCBzdG9yZSBpdCBzdHJpbmdpZmllZFxuICAgICAgICBzdG9yZWRPYmplY3QuZGVsZXRlZCA9IHN0b3JlZE9iamVjdC5kZWxldGVkT3JMb2NhbCA9PT0gJzEnO1xuICAgICAgICByZXR1cm4gc3RvcmVkT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZU1ldGFkYXRhKHN0b3JlZE9iamVjdCk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgbWV0YWRhdGEgaGFzIGEgd2lubmluZ1JldiBhbmQgc2VxLFxuICAgIC8vIHdoaWNoIHdhcyBwcmV2aW91c2x5IGNyZWF0ZWQgb24tdGhlLWZseSBidXQgYmV0dGVyIHRvIG1pZ3JhdGVcbiAgICB2YXIgYnlTZXFTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShCWV9TRVFfU1RPUkUpO1xuICAgIHZhciBkb2NTdG9yZSA9IHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuICAgIHZhciBjdXJzb3IgPSBkb2NTdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgY3Vyc29yLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKCFjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBkb25lXG4gICAgICB9XG4gICAgICB2YXIgbWV0YWRhdGEgPSBkZWNvZGVNZXRhZGF0YUNvbXBhdChjdXJzb3IudmFsdWUpO1xuXG4gICAgICBtZXRhZGF0YS53aW5uaW5nUmV2ID0gbWV0YWRhdGEud2lubmluZ1JldiB8fFxuICAgICAgICB3aW5uaW5nUmV2KG1ldGFkYXRhKTtcblxuICAgICAgZnVuY3Rpb24gZmV0Y2hNZXRhZGF0YVNlcSgpIHtcbiAgICAgICAgLy8gbWV0YWRhdGEuc2VxIHdhcyBhZGRlZCBwb3N0LTMuMi4wLCBzbyBpZiBpdCdzIG1pc3NpbmcsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZmV0Y2ggaXQgbWFudWFsbHlcbiAgICAgICAgdmFyIHN0YXJ0ID0gbWV0YWRhdGEuaWQgKyAnOjonO1xuICAgICAgICB2YXIgZW5kID0gbWV0YWRhdGEuaWQgKyAnOjpcXHVmZmZmJztcbiAgICAgICAgdmFyIHJlcSA9IGJ5U2VxU3RvcmUuaW5kZXgoJ19kb2NfaWRfcmV2Jykub3BlbkN1cnNvcihcbiAgICAgICAgICBJREJLZXlSYW5nZS5ib3VuZChzdGFydCwgZW5kKSk7XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhU2VxID0gMDtcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgbWV0YWRhdGEuc2VxID0gbWV0YWRhdGFTZXE7XG4gICAgICAgICAgICByZXR1cm4gb25HZXRNZXRhZGF0YVNlcSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2VxID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgaWYgKHNlcSA+IG1ldGFkYXRhU2VxKSB7XG4gICAgICAgICAgICBtZXRhZGF0YVNlcSA9IHNlcTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uR2V0TWV0YWRhdGFTZXEoKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YVRvU3RvcmUgPSBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSxcbiAgICAgICAgICBtZXRhZGF0YS53aW5uaW5nUmV2LCBtZXRhZGF0YS5kZWxldGVkKTtcblxuICAgICAgICB2YXIgcmVxID0gZG9jU3RvcmUucHV0KG1ldGFkYXRhVG9TdG9yZSk7XG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRhZGF0YS5zZXEpIHtcbiAgICAgICAgcmV0dXJuIG9uR2V0TWV0YWRhdGFTZXEoKTtcbiAgICAgIH1cblxuICAgICAgZmV0Y2hNZXRhZGF0YVNlcSgpO1xuICAgIH07XG5cbiAgfVxuXG4gIGFwaS5fcmVtb3RlID0gZmFsc2U7XG4gIGFwaS50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnaWRiJztcbiAgfTtcblxuICBhcGkuX2lkID0gdG9Qcm9taXNlKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKG51bGwsIGFwaS5fbWV0YS5pbnN0YW5jZUlkKTtcbiAgfSk7XG5cbiAgYXBpLl9idWxrRG9jcyA9IGZ1bmN0aW9uIGlkYl9idWxrRG9jcyhyZXEsIHJlcU9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWRiQnVsa0RvY3Mob3B0cywgcmVxLCByZXFPcHRzLCBhcGksIGlkYiwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIEZpcnN0IHdlIGxvb2sgdXAgdGhlIG1ldGFkYXRhIGluIHRoZSBpZHMgZGF0YWJhc2UsIHRoZW4gd2UgZmV0Y2ggdGhlXG4gIC8vIGN1cnJlbnQgcmV2aXNpb24ocykgZnJvbSB0aGUgYnkgc2VxdWVuY2Ugc3RvcmVcbiAgYXBpLl9nZXQgPSBmdW5jdGlvbiBpZGJfZ2V0KGlkLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBkb2M7XG4gICAgdmFyIG1ldGFkYXRhO1xuICAgIHZhciBlcnI7XG4gICAgdmFyIHR4biA9IG9wdHMuY3R4O1xuICAgIGlmICghdHhuKSB7XG4gICAgICB2YXIgdHhuUmVzdWx0ID0gb3BlblRyYW5zYWN0aW9uU2FmZWx5KGlkYixcbiAgICAgICAgW0RPQ19TVE9SRSwgQllfU0VRX1NUT1JFLCBBVFRBQ0hfU1RPUkVdLCAncmVhZG9ubHknKTtcbiAgICAgIGlmICh0eG5SZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR4blJlc3VsdC5lcnJvcik7XG4gICAgICB9XG4gICAgICB0eG4gPSB0eG5SZXN1bHQudHhuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwge2RvYzogZG9jLCBtZXRhZGF0YTogbWV0YWRhdGEsIGN0eDogdHhufSk7XG4gICAgfVxuXG4gICAgdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSkuZ2V0KGlkKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgbWV0YWRhdGEgPSBkZWNvZGVNZXRhZGF0YShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgLy8gd2UgY2FuIGRldGVybWluZSB0aGUgcmVzdWx0IGhlcmUgaWY6XG4gICAgICAvLyAxLiB0aGVyZSBpcyBubyBzdWNoIGRvY3VtZW50XG4gICAgICAvLyAyLiB0aGUgZG9jdW1lbnQgaXMgZGVsZXRlZCBhbmQgd2UgZG9uJ3QgYXNrIGFib3V0IHNwZWNpZmljIHJldlxuICAgICAgLy8gV2hlbiB3ZSBhc2sgd2l0aCBvcHRzLnJldiB3ZSBleHBlY3QgdGhlIGFuc3dlciB0byBiZSBlaXRoZXJcbiAgICAgIC8vIGRvYyAocG9zc2libHkgd2l0aCBfZGVsZXRlZD10cnVlKSBvciBtaXNzaW5nIGVycm9yXG4gICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgIGVyciA9IGNyZWF0ZUVycm9yKE1JU1NJTkdfRE9DLCAnbWlzc2luZycpO1xuICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXY7XG4gICAgICBpZiAoIW9wdHMucmV2KSB7XG4gICAgICAgIHJldiA9IG1ldGFkYXRhLndpbm5pbmdSZXY7XG4gICAgICAgIHZhciBkZWxldGVkID0gaXNEZWxldGVkKG1ldGFkYXRhKTtcbiAgICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgICBlcnIgPSBjcmVhdGVFcnJvcihNSVNTSU5HX0RPQywgXCJkZWxldGVkXCIpO1xuICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ID0gb3B0cy5sYXRlc3QgPyBsYXRlc3Qob3B0cy5yZXYsIG1ldGFkYXRhKSA6IG9wdHMucmV2O1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFKTtcbiAgICAgIHZhciBrZXkgPSBtZXRhZGF0YS5pZCArICc6OicgKyByZXY7XG5cbiAgICAgIG9iamVjdFN0b3JlLmluZGV4KCdfZG9jX2lkX3JldicpLmdldChrZXkpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgIGRvYyA9IGRlY29kZURvYyhkb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9jKSB7XG4gICAgICAgICAgZXJyID0gY3JlYXRlRXJyb3IoTUlTU0lOR19ET0MsICdtaXNzaW5nJyk7XG4gICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIGFwaS5fZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIChkb2NJZCwgYXR0YWNoSWQsIGF0dGFjaG1lbnQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHR4bjtcbiAgICBpZiAob3B0cy5jdHgpIHtcbiAgICAgIHR4biA9IG9wdHMuY3R4O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHhuUmVzdWx0ID0gb3BlblRyYW5zYWN0aW9uU2FmZWx5KGlkYixcbiAgICAgICAgW0RPQ19TVE9SRSwgQllfU0VRX1NUT1JFLCBBVFRBQ0hfU1RPUkVdLCAncmVhZG9ubHknKTtcbiAgICAgIGlmICh0eG5SZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR4blJlc3VsdC5lcnJvcik7XG4gICAgICB9XG4gICAgICB0eG4gPSB0eG5SZXN1bHQudHhuO1xuICAgIH1cbiAgICB2YXIgZGlnZXN0ID0gYXR0YWNobWVudC5kaWdlc3Q7XG4gICAgdmFyIHR5cGUgPSBhdHRhY2htZW50LmNvbnRlbnRfdHlwZTtcblxuICAgIHR4bi5vYmplY3RTdG9yZShBVFRBQ0hfU1RPUkUpLmdldChkaWdlc3QpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgYm9keSA9IGUudGFyZ2V0LnJlc3VsdC5ib2R5O1xuICAgICAgcmVhZEJsb2JEYXRhKGJvZHksIHR5cGUsIG9wdHMuYmluYXJ5LCBmdW5jdGlvbiAoYmxvYkRhdGEpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYmxvYkRhdGEpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBhcGkuX2luZm8gPSBmdW5jdGlvbiBpZGJfaW5mbyhjYWxsYmFjaykge1xuICAgIHZhciB1cGRhdGVTZXE7XG4gICAgdmFyIGRvY0NvdW50O1xuXG4gICAgdmFyIHR4blJlc3VsdCA9IG9wZW5UcmFuc2FjdGlvblNhZmVseShpZGIsIFtNRVRBX1NUT1JFLCBCWV9TRVFfU1RPUkVdLCAncmVhZG9ubHknKTtcbiAgICBpZiAodHhuUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodHhuUmVzdWx0LmVycm9yKTtcbiAgICB9XG4gICAgdmFyIHR4biA9IHR4blJlc3VsdC50eG47XG4gICAgdHhuLm9iamVjdFN0b3JlKE1FVEFfU1RPUkUpLmdldChNRVRBX1NUT1JFKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZG9jQ291bnQgPSBlLnRhcmdldC5yZXN1bHQuZG9jQ291bnQ7XG4gICAgfTtcbiAgICB0eG4ub2JqZWN0U3RvcmUoQllfU0VRX1NUT1JFKS5vcGVuQ3Vyc29yKG51bGwsICdwcmV2Jykub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICB1cGRhdGVTZXEgPSBjdXJzb3IgPyBjdXJzb3Iua2V5IDogMDtcbiAgICB9O1xuXG4gICAgdHhuLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIGRvY19jb3VudDogZG9jQ291bnQsXG4gICAgICAgIHVwZGF0ZV9zZXE6IHVwZGF0ZVNlcSxcbiAgICAgICAgLy8gZm9yIGRlYnVnZ2luZ1xuICAgICAgICBpZGJfYXR0YWNobWVudF9mb3JtYXQ6IChhcGkuX21ldGEuYmxvYlN1cHBvcnQgPyAnYmluYXJ5JyA6ICdiYXNlNjQnKVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBhcGkuX2FsbERvY3MgPSBmdW5jdGlvbiBpZGJfYWxsRG9jcyhvcHRzLCBjYWxsYmFjaykge1xuICAgIGlkYkFsbERvY3Mob3B0cywgaWRiLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgYXBpLl9jaGFuZ2VzID0gZnVuY3Rpb24gaWRiQ2hhbmdlcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNoYW5nZXMob3B0cywgYXBpLCBkYk5hbWUsIGlkYik7XG4gIH07XG5cbiAgYXBpLl9jbG9zZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSW5kZXhlZERCL0lEQkRhdGFiYXNlI2Nsb3NlXG4gICAgLy8gXCJSZXR1cm5zIGltbWVkaWF0ZWx5IGFuZCBjbG9zZXMgdGhlIGNvbm5lY3Rpb24gaW4gYSBzZXBhcmF0ZSB0aHJlYWQuLi5cIlxuICAgIGlkYi5jbG9zZSgpO1xuICAgIGNhY2hlZERCcy5kZWxldGUoZGJOYW1lKTtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIGFwaS5fZ2V0UmV2aXNpb25UcmVlID0gZnVuY3Rpb24gKGRvY0lkLCBjYWxsYmFjaykge1xuICAgIHZhciB0eG5SZXN1bHQgPSBvcGVuVHJhbnNhY3Rpb25TYWZlbHkoaWRiLCBbRE9DX1NUT1JFXSwgJ3JlYWRvbmx5Jyk7XG4gICAgaWYgKHR4blJlc3VsdC5lcnJvcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHR4blJlc3VsdC5lcnJvcik7XG4gICAgfVxuICAgIHZhciB0eG4gPSB0eG5SZXN1bHQudHhuO1xuICAgIHZhciByZXEgPSB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoZG9jSWQpO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBkb2MgPSBkZWNvZGVNZXRhZGF0YShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgIGlmICghZG9jKSB7XG4gICAgICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKE1JU1NJTkdfRE9DKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBkb2MucmV2X3RyZWUpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZW1vdmVzIHJldmlzaW9ucyBvZiBkb2N1bWVudCBkb2NJZFxuICAvLyB3aGljaCBhcmUgbGlzdGVkIGluIHJldnMgYW5kIHNldHMgdGhpcyBkb2N1bWVudFxuICAvLyByZXZpc2lvbiB0byB0byByZXZfdHJlZVxuICBhcGkuX2RvQ29tcGFjdGlvbiA9IGZ1bmN0aW9uIChkb2NJZCwgcmV2cywgY2FsbGJhY2spIHtcbiAgICB2YXIgc3RvcmVzID0gW1xuICAgICAgRE9DX1NUT1JFLFxuICAgICAgQllfU0VRX1NUT1JFLFxuICAgICAgQVRUQUNIX1NUT1JFLFxuICAgICAgQVRUQUNIX0FORF9TRVFfU1RPUkVcbiAgICBdO1xuICAgIHZhciB0eG5SZXN1bHQgPSBvcGVuVHJhbnNhY3Rpb25TYWZlbHkoaWRiLCBzdG9yZXMsICdyZWFkd3JpdGUnKTtcbiAgICBpZiAodHhuUmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodHhuUmVzdWx0LmVycm9yKTtcbiAgICB9XG4gICAgdmFyIHR4biA9IHR4blJlc3VsdC50eG47XG5cbiAgICB2YXIgZG9jU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcblxuICAgIGRvY1N0b3JlLmdldChkb2NJZCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgbWV0YWRhdGEgPSBkZWNvZGVNZXRhZGF0YShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgIHRyYXZlcnNlUmV2VHJlZShtZXRhZGF0YS5yZXZfdHJlZSwgZnVuY3Rpb24gKGlzTGVhZiwgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2SGFzaCwgY3R4LCBvcHRzKSB7XG4gICAgICAgIHZhciByZXYgPSBwb3MgKyAnLScgKyByZXZIYXNoO1xuICAgICAgICBpZiAocmV2cy5pbmRleE9mKHJldikgIT09IC0xKSB7XG4gICAgICAgICAgb3B0cy5zdGF0dXMgPSAnbWlzc2luZyc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29tcGFjdFJldnMocmV2cywgZG9jSWQsIHR4bik7XG4gICAgICB2YXIgd2lubmluZ1JldiQkMSA9IG1ldGFkYXRhLndpbm5pbmdSZXY7XG4gICAgICB2YXIgZGVsZXRlZCA9IG1ldGFkYXRhLmRlbGV0ZWQ7XG4gICAgICB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5wdXQoXG4gICAgICAgIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhLCB3aW5uaW5nUmV2JCQxLCBkZWxldGVkKSk7XG4gICAgfTtcbiAgICB0eG4ub25hYm9ydCA9IGlkYkVycm9yKGNhbGxiYWNrKTtcbiAgICB0eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfTtcblxuXG4gIGFwaS5fZ2V0TG9jYWwgPSBmdW5jdGlvbiAoaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHR4blJlc3VsdCA9IG9wZW5UcmFuc2FjdGlvblNhZmVseShpZGIsIFtMT0NBTF9TVE9SRV0sICdyZWFkb25seScpO1xuICAgIGlmICh0eG5SZXN1bHQuZXJyb3IpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0eG5SZXN1bHQuZXJyb3IpO1xuICAgIH1cbiAgICB2YXIgdHggPSB0eG5SZXN1bHQudHhuO1xuICAgIHZhciByZXEgPSB0eC5vYmplY3RTdG9yZShMT0NBTF9TVE9SRSkuZ2V0KGlkKTtcblxuICAgIHJlcS5vbmVycm9yID0gaWRiRXJyb3IoY2FsbGJhY2spO1xuICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgIGlmICghZG9jKSB7XG4gICAgICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKE1JU1NJTkdfRE9DKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgZG9jWydfZG9jX2lkX3JldiddOyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgICAgICBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgYXBpLl9wdXRMb2NhbCA9IGZ1bmN0aW9uIChkb2MsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGRlbGV0ZSBkb2MuX3JldmlzaW9uczsgLy8gaWdub3JlIHRoaXMsIHRydXN0IHRoZSByZXZcbiAgICB2YXIgb2xkUmV2ID0gZG9jLl9yZXY7XG4gICAgdmFyIGlkID0gZG9jLl9pZDtcbiAgICBpZiAoIW9sZFJldikge1xuICAgICAgZG9jLl9yZXYgPSAnMC0xJztcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jLl9yZXYgPSAnMC0nICsgKHBhcnNlSW50KG9sZFJldi5zcGxpdCgnLScpWzFdLCAxMCkgKyAxKTtcbiAgICB9XG5cbiAgICB2YXIgdHggPSBvcHRzLmN0eDtcbiAgICB2YXIgcmV0O1xuICAgIGlmICghdHgpIHtcbiAgICAgIHZhciB0eG5SZXN1bHQgPSBvcGVuVHJhbnNhY3Rpb25TYWZlbHkoaWRiLCBbTE9DQUxfU1RPUkVdLCAncmVhZHdyaXRlJyk7XG4gICAgICBpZiAodHhuUmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0eG5SZXN1bHQuZXJyb3IpO1xuICAgICAgfVxuICAgICAgdHggPSB0eG5SZXN1bHQudHhuO1xuICAgICAgdHgub25lcnJvciA9IGlkYkVycm9yKGNhbGxiYWNrKTtcbiAgICAgIHR4Lm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvU3RvcmUgPSB0eC5vYmplY3RTdG9yZShMT0NBTF9TVE9SRSk7XG4gICAgdmFyIHJlcTtcbiAgICBpZiAob2xkUmV2KSB7XG4gICAgICByZXEgPSBvU3RvcmUuZ2V0KGlkKTtcbiAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgb2xkRG9jID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoIW9sZERvYyB8fCBvbGREb2MuX3JldiAhPT0gb2xkUmV2KSB7XG4gICAgICAgICAgY2FsbGJhY2soY3JlYXRlRXJyb3IoUkVWX0NPTkZMSUNUKSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIHVwZGF0ZVxuICAgICAgICAgIHZhciByZXEgPSBvU3RvcmUucHV0KGRvYyk7XG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldCA9IHtvazogdHJ1ZSwgaWQ6IGRvYy5faWQsIHJldjogZG9jLl9yZXZ9O1xuICAgICAgICAgICAgaWYgKG9wdHMuY3R4KSB7IC8vIHJldHVybiBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHsgLy8gbmV3IGRvY1xuICAgICAgcmVxID0gb1N0b3JlLmFkZChkb2MpO1xuICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBjb25zdHJhaW50IGVycm9yLCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBjYWxsYmFjayhjcmVhdGVFcnJvcihSRVZfQ09ORkxJQ1QpKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBhdm9pZCB0cmFuc2FjdGlvbiBhYm9ydFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBhdm9pZCB0cmFuc2FjdGlvbiBvbmVycm9yXG4gICAgICB9O1xuICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0ID0ge29rOiB0cnVlLCBpZDogZG9jLl9pZCwgcmV2OiBkb2MuX3Jldn07XG4gICAgICAgIGlmIChvcHRzLmN0eCkgeyAvLyByZXR1cm4gaW1tZWRpYXRlbHlcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBhcGkuX3JlbW92ZUxvY2FsID0gZnVuY3Rpb24gKGRvYywgb3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgdmFyIHR4ID0gb3B0cy5jdHg7XG4gICAgaWYgKCF0eCkge1xuICAgICAgdmFyIHR4blJlc3VsdCA9IG9wZW5UcmFuc2FjdGlvblNhZmVseShpZGIsIFtMT0NBTF9TVE9SRV0sICdyZWFkd3JpdGUnKTtcbiAgICAgIGlmICh0eG5SZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR4blJlc3VsdC5lcnJvcik7XG4gICAgICB9XG4gICAgICB0eCA9IHR4blJlc3VsdC50eG47XG4gICAgICB0eC5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmV0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHJldDtcbiAgICB2YXIgaWQgPSBkb2MuX2lkO1xuICAgIHZhciBvU3RvcmUgPSB0eC5vYmplY3RTdG9yZShMT0NBTF9TVE9SRSk7XG4gICAgdmFyIHJlcSA9IG9TdG9yZS5nZXQoaWQpO1xuXG4gICAgcmVxLm9uZXJyb3IgPSBpZGJFcnJvcihjYWxsYmFjayk7XG4gICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgb2xkRG9jID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKCFvbGREb2MgfHwgb2xkRG9jLl9yZXYgIT09IGRvYy5fcmV2KSB7XG4gICAgICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKE1JU1NJTkdfRE9DKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvU3RvcmUuZGVsZXRlKGlkKTtcbiAgICAgICAgcmV0ID0ge29rOiB0cnVlLCBpZDogaWQsIHJldjogJzAtMCd9O1xuICAgICAgICBpZiAob3B0cy5jdHgpIHsgLy8gcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgYXBpLl9kZXN0cm95ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgY2hhbmdlc0hhbmRsZXIkMS5yZW1vdmVBbGxMaXN0ZW5lcnMoZGJOYW1lKTtcblxuICAgIC8vQ2xvc2Ugb3BlbiByZXF1ZXN0IGZvciBcImRiTmFtZVwiIGRhdGFiYXNlIHRvIGZpeCBpZSBkZWxheS5cbiAgICB2YXIgb3BlblJlcSA9IG9wZW5SZXFMaXN0LmdldChkYk5hbWUpO1xuICAgIGlmIChvcGVuUmVxICYmIG9wZW5SZXEucmVzdWx0KSB7XG4gICAgICBvcGVuUmVxLnJlc3VsdC5jbG9zZSgpO1xuICAgICAgY2FjaGVkREJzLmRlbGV0ZShkYk5hbWUpO1xuICAgIH1cbiAgICB2YXIgcmVxID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiTmFtZSk7XG5cbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy9SZW1vdmUgb3BlbiByZXF1ZXN0IGZyb20gdGhlIGxpc3QuXG4gICAgICBvcGVuUmVxTGlzdC5kZWxldGUoZGJOYW1lKTtcbiAgICAgIGlmIChoYXNMb2NhbFN0b3JhZ2UoKSAmJiAoZGJOYW1lIGluIGxvY2FsU3RvcmFnZSkpIHtcbiAgICAgICAgZGVsZXRlIGxvY2FsU3RvcmFnZVtkYk5hbWVdO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgeyAnb2snOiB0cnVlIH0pO1xuICAgIH07XG5cbiAgICByZXEub25lcnJvciA9IGlkYkVycm9yKGNhbGxiYWNrKTtcbiAgfTtcblxuICB2YXIgY2FjaGVkID0gY2FjaGVkREJzLmdldChkYk5hbWUpO1xuXG4gIGlmIChjYWNoZWQpIHtcbiAgICBpZGIgPSBjYWNoZWQuaWRiO1xuICAgIGFwaS5fbWV0YSA9IGNhY2hlZC5nbG9iYWw7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGFwaSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcmVxID0gaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBBREFQVEVSX1ZFUlNJT04pO1xuICBvcGVuUmVxTGlzdC5zZXQoZGJOYW1lLCByZXEpO1xuXG4gIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkYiA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICBpZiAoZS5vbGRWZXJzaW9uIDwgMSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNjaGVtYShkYik7IC8vIG5ldyBkYiwgaW5pdGlhbCBzY2hlbWFcbiAgICB9XG4gICAgLy8gZG8gbWlncmF0aW9uc1xuXG4gICAgdmFyIHR4biA9IGUuY3VycmVudFRhcmdldC50cmFuc2FjdGlvbjtcbiAgICAvLyB0aGVzZSBtaWdyYXRpb25zIGhhdmUgdG8gYmUgZG9uZSBpbiB0aGlzIGZ1bmN0aW9uLCBiZWZvcmVcbiAgICAvLyBjb250cm9sIGlzIHJldHVybmVkIHRvIHRoZSBldmVudCBsb29wLCBiZWNhdXNlIEluZGV4ZWREQlxuXG4gICAgaWYgKGUub2xkVmVyc2lvbiA8IDMpIHtcbiAgICAgIGNyZWF0ZUxvY2FsU3RvcmVTY2hlbWEoZGIpOyAvLyB2MiAtPiB2M1xuICAgIH1cbiAgICBpZiAoZS5vbGRWZXJzaW9uIDwgNCkge1xuICAgICAgYWRkQXR0YWNoQW5kU2VxU3RvcmUoZGIpOyAvLyB2MyAtPiB2NFxuICAgIH1cblxuICAgIHZhciBtaWdyYXRpb25zID0gW1xuICAgICAgYWRkRGVsZXRlZE9yTG9jYWxJbmRleCwgLy8gdjEgLT4gdjJcbiAgICAgIG1pZ3JhdGVMb2NhbFN0b3JlLCAgICAgIC8vIHYyIC0+IHYzXG4gICAgICBtaWdyYXRlQXR0c0FuZFNlcXMsICAgICAvLyB2MyAtPiB2NFxuICAgICAgbWlncmF0ZU1ldGFkYXRhICAgICAgICAgLy8gdjQgLT4gdjVcbiAgICBdO1xuXG4gICAgdmFyIGkgPSBlLm9sZFZlcnNpb247XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIG1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNbaSAtIDFdO1xuICAgICAgaSsrO1xuICAgICAgaWYgKG1pZ3JhdGlvbikge1xuICAgICAgICBtaWdyYXRpb24odHhuLCBuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0KCk7XG4gIH07XG5cbiAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG5cbiAgICBpZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICBpZGIub252ZXJzaW9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWRiLmNsb3NlKCk7XG4gICAgICBjYWNoZWREQnMuZGVsZXRlKGRiTmFtZSk7XG4gICAgfTtcblxuICAgIGlkYi5vbmFib3J0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGd1YXJkZWRDb25zb2xlKCdlcnJvcicsICdEYXRhYmFzZSBoYXMgYSBnbG9iYWwgZmFpbHVyZScsIGUudGFyZ2V0LmVycm9yKTtcbiAgICAgIGlkYi5jbG9zZSgpO1xuICAgICAgY2FjaGVkREJzLmRlbGV0ZShkYk5hbWUpO1xuICAgIH07XG5cbiAgICAvLyBEbyBhIGZldyBzZXR1cCBvcGVyYXRpb25zIChpbiBwYXJhbGxlbCBhcyBtdWNoIGFzIHBvc3NpYmxlKTpcbiAgICAvLyAxLiBGZXRjaCBtZXRhIGRvY1xuICAgIC8vIDIuIENoZWNrIGJsb2Igc3VwcG9ydFxuICAgIC8vIDMuIENhbGN1bGF0ZSBkb2NDb3VudFxuICAgIC8vIDQuIEdlbmVyYXRlIGFuIGluc3RhbmNlSWQgaWYgbmVjZXNzYXJ5XG4gICAgLy8gNS4gU3RvcmUgZG9jQ291bnQgYW5kIGluc3RhbmNlSWQgb24gbWV0YSBkb2NcblxuICAgIHZhciB0eG4gPSBpZGIudHJhbnNhY3Rpb24oW1xuICAgICAgTUVUQV9TVE9SRSxcbiAgICAgIERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUsXG4gICAgICBET0NfU1RPUkVcbiAgICBdLCAncmVhZHdyaXRlJyk7XG5cbiAgICB2YXIgc3RvcmVkTWV0YURvYyA9IGZhbHNlO1xuICAgIHZhciBtZXRhRG9jO1xuICAgIHZhciBkb2NDb3VudDtcbiAgICB2YXIgYmxvYlN1cHBvcnQ7XG4gICAgdmFyIGluc3RhbmNlSWQ7XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVNldHVwKCkge1xuICAgICAgaWYgKHR5cGVvZiBibG9iU3VwcG9ydCA9PT0gJ3VuZGVmaW5lZCcgfHwgIXN0b3JlZE1ldGFEb2MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLl9tZXRhID0ge1xuICAgICAgICBuYW1lOiBkYk5hbWUsXG4gICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlSWQsXG4gICAgICAgIGJsb2JTdXBwb3J0OiBibG9iU3VwcG9ydFxuICAgICAgfTtcblxuICAgICAgY2FjaGVkREJzLnNldChkYk5hbWUsIHtcbiAgICAgICAgaWRiOiBpZGIsXG4gICAgICAgIGdsb2JhbDogYXBpLl9tZXRhXG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGFwaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcmVNZXRhRG9jSWZSZWFkeSgpIHtcbiAgICAgIGlmICh0eXBlb2YgZG9jQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBtZXRhRG9jID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW5zdGFuY2VLZXkgPSBkYk5hbWUgKyAnX2lkJztcbiAgICAgIGlmIChpbnN0YW5jZUtleSBpbiBtZXRhRG9jKSB7XG4gICAgICAgIGluc3RhbmNlSWQgPSBtZXRhRG9jW2luc3RhbmNlS2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFEb2NbaW5zdGFuY2VLZXldID0gaW5zdGFuY2VJZCA9IHV1aWQoKTtcbiAgICAgIH1cbiAgICAgIG1ldGFEb2MuZG9jQ291bnQgPSBkb2NDb3VudDtcbiAgICAgIHR4bi5vYmplY3RTdG9yZShNRVRBX1NUT1JFKS5wdXQobWV0YURvYyk7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBmZXRjaCBvciBnZW5lcmF0ZSB0aGUgaW5zdGFuY2VJZFxuICAgIC8vXG4gICAgdHhuLm9iamVjdFN0b3JlKE1FVEFfU1RPUkUpLmdldChNRVRBX1NUT1JFKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgbWV0YURvYyA9IGUudGFyZ2V0LnJlc3VsdCB8fCB7IGlkOiBNRVRBX1NUT1JFIH07XG4gICAgICBzdG9yZU1ldGFEb2NJZlJlYWR5KCk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gY291bnREb2NzXG4gICAgLy9cbiAgICBjb3VudERvY3ModHhuLCBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgIGRvY0NvdW50ID0gY291bnQ7XG4gICAgICBzdG9yZU1ldGFEb2NJZlJlYWR5KCk7XG4gICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIGNoZWNrIGJsb2Igc3VwcG9ydFxuICAgIC8vXG4gICAgaWYgKCFibG9iU3VwcG9ydFByb21pc2UpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBibG9iIHN1cHBvcnQgaXMgb25seSBjaGVja2VkIG9uY2VcbiAgICAgIGJsb2JTdXBwb3J0UHJvbWlzZSA9IGNoZWNrQmxvYlN1cHBvcnQodHhuKTtcbiAgICB9XG5cbiAgICBibG9iU3VwcG9ydFByb21pc2UudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICBibG9iU3VwcG9ydCA9IHZhbDtcbiAgICAgIGNvbXBsZXRlU2V0dXAoKTtcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgd2hlbiB0aGUgbWV0YWRhdGEgcHV0IHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQsXG4gICAgLy8gY29uc2lkZXIgdGhlIHNldHVwIGRvbmVcbiAgICB0eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0b3JlZE1ldGFEb2MgPSB0cnVlO1xuICAgICAgY29tcGxldGVTZXR1cCgpO1xuICAgIH07XG4gICAgdHhuLm9uYWJvcnQgPSBpZGJFcnJvcihjYWxsYmFjayk7XG4gIH07XG5cbiAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtc2cgPSBlLnRhcmdldC5lcnJvciAmJiBlLnRhcmdldC5lcnJvci5tZXNzYWdlO1xuXG4gICAgaWYgKCFtc2cpIHtcbiAgICAgIG1zZyA9ICdGYWlsZWQgdG8gb3BlbiBpbmRleGVkREIsIGFyZSB5b3UgaW4gcHJpdmF0ZSBicm93c2luZyBtb2RlPyc7XG4gICAgfSBlbHNlIGlmIChtc2cuaW5kZXhPZihcInN0b3JlZCBkYXRhYmFzZSBpcyBhIGhpZ2hlciB2ZXJzaW9uXCIpICE9PSAtMSkge1xuICAgICAgbXNnID0gbmV3IEVycm9yKCdUaGlzIERCIHdhcyBjcmVhdGVkIHdpdGggdGhlIG5ld2VyIFwiaW5kZXhlZGRiXCIgYWRhcHRlciwgYnV0IHlvdSBhcmUgdHJ5aW5nIHRvIG9wZW4gaXQgd2l0aCB0aGUgb2xkZXIgXCJpZGJcIiBhZGFwdGVyJyk7XG4gICAgfVxuXG4gICAgZ3VhcmRlZENvbnNvbGUoJ2Vycm9yJywgbXNnKTtcbiAgICBjYWxsYmFjayhjcmVhdGVFcnJvcihJREJfRVJST1IsIG1zZykpO1xuICB9O1xufVxuXG5JZGJQb3VjaC52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRm9sbG93aW5nICM3MDg1IGJ1Z2d5IGlkYiB2ZXJzaW9ucyAodHlwaWNhbGx5IFNhZmFyaSA8IDEwLjEpIGFyZVxuICAvLyBjb25zaWRlcmVkIHZhbGlkLlxuXG4gIC8vIE9uIEZpcmVmb3ggU2VjdXJpdHlFcnJvciBpcyB0aHJvd24gd2hpbGUgcmVmZXJlbmNpbmcgaW5kZXhlZERCIGlmIGNvb2tpZXNcbiAgLy8gYXJlIG5vdCBhbGxvd2VkLiBgdHlwZW9mIGluZGV4ZWREQmAgYWxzbyB0cmlnZ2VycyB0aGUgZXJyb3IuXG4gIHRyeSB7XG4gICAgLy8gc29tZSBvdXRkYXRlZCBpbXBsZW1lbnRhdGlvbnMgb2YgSURCIHRoYXQgYXBwZWFyIG9uIFNhbXN1bmdcbiAgICAvLyBhbmQgSFRDIEFuZHJvaWQgZGV2aWNlcyA8NC40IGFyZSBtaXNzaW5nIElEQktleVJhbmdlXG4gICAgcmV0dXJuIHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBJREJLZXlSYW5nZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluZGV4IChQb3VjaERCKSB7XG4gIFBvdWNoREIuYWRhcHRlcignaWRiJywgSWRiUG91Y2gsIHRydWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsImltcG9ydCB7IGFzc2lnbiwgdXVpZCwgcmV2LCBpbnZhbGlkSWRFcnJvciwgbm9ybWFsaXplRGRvY0Z1bmN0aW9uTmFtZSwgcGFyc2VEZG9jRnVuY3Rpb25OYW1lIH0gZnJvbSAncG91Y2hkYi11dGlscyc7XG5leHBvcnQgeyBpbnZhbGlkSWRFcnJvciwgbm9ybWFsaXplRGRvY0Z1bmN0aW9uTmFtZSwgcGFyc2VEZG9jRnVuY3Rpb25OYW1lIH0gZnJvbSAncG91Y2hkYi11dGlscyc7XG5pbXBvcnQgeyBhdG9iLCBidG9hLCBiaW5hcnlTdHJpbmdUb0Jsb2JPckJ1ZmZlciwgYmxvYk9yQnVmZmVyVG9CaW5hcnlTdHJpbmcsIGJsb2JPckJ1ZmZlclRvQmFzZTY0IH0gZnJvbSAncG91Y2hkYi1iaW5hcnktdXRpbHMnO1xuaW1wb3J0IHsgYmluYXJ5TWQ1IH0gZnJvbSAncG91Y2hkYi1tZDUnO1xuaW1wb3J0IHsgTWFwIH0gZnJvbSAncG91Y2hkYi1jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBET0NfVkFMSURBVElPTiwgSU5WQUxJRF9SRVYsIGNyZWF0ZUVycm9yLCBCQURfQVJHLCBSRVZfQ09ORkxJQ1QsIE1JU1NJTkdfRE9DIH0gZnJvbSAncG91Y2hkYi1lcnJvcnMnO1xuaW1wb3J0IHsgaXNEZWxldGVkLCBtZXJnZSwgd2lubmluZ1JldiwgcmV2RXhpc3RzLCBpc0xvY2FsSWQgfSBmcm9tICdwb3VjaGRiLW1lcmdlJztcbmV4cG9ydCB7IGlzRGVsZXRlZCwgaXNMb2NhbElkIH0gZnJvbSAncG91Y2hkYi1tZXJnZSc7XG5cbmZ1bmN0aW9uIGFsbERvY3NLZXlzUXVlcnkoYXBpLCBvcHRzKSB7XG4gIHZhciBrZXlzID0gb3B0cy5rZXlzO1xuICB2YXIgZmluYWxSZXN1bHRzID0ge1xuICAgIG9mZnNldDogb3B0cy5za2lwXG4gIH07XG4gIHJldHVybiBQcm9taXNlLmFsbChrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN1Yk9wdHMgPSBhc3NpZ24oe2tleToga2V5LCBkZWxldGVkOiAnb2snfSwgb3B0cyk7XG4gICAgWydsaW1pdCcsICdza2lwJywgJ2tleXMnXS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRLZXkpIHtcbiAgICAgIGRlbGV0ZSBzdWJPcHRzW29wdEtleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFwaS5fYWxsRG9jcyhzdWJPcHRzLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChvcHRzLnVwZGF0ZV9zZXEgJiYgcmVzLnVwZGF0ZV9zZXEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZpbmFsUmVzdWx0cy51cGRhdGVfc2VxID0gcmVzLnVwZGF0ZV9zZXE7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxSZXN1bHRzLnRvdGFsX3Jvd3MgPSByZXMudG90YWxfcm93cztcbiAgICAgICAgcmVzb2x2ZShyZXMucm93c1swXSB8fCB7a2V5OiBrZXksIGVycm9yOiAnbm90X2ZvdW5kJ30pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgZmluYWxSZXN1bHRzLnJvd3MgPSByZXN1bHRzO1xuICAgIHJldHVybiBmaW5hbFJlc3VsdHM7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdChhcnJheSkge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGl0ZW0pIHtcbiAgICBvYmpbaXRlbV0gPSB0cnVlO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn1cbi8vIExpc3Qgb2YgdG9wIGxldmVsIHJlc2VydmVkIHdvcmRzIGZvciBkb2NcbnZhciByZXNlcnZlZFdvcmRzID0gdG9PYmplY3QoW1xuICAnX2lkJyxcbiAgJ19yZXYnLFxuICAnX2F0dGFjaG1lbnRzJyxcbiAgJ19kZWxldGVkJyxcbiAgJ19yZXZpc2lvbnMnLFxuICAnX3JldnNfaW5mbycsXG4gICdfY29uZmxpY3RzJyxcbiAgJ19kZWxldGVkX2NvbmZsaWN0cycsXG4gICdfbG9jYWxfc2VxJyxcbiAgJ19yZXZfdHJlZScsXG4gIC8vcmVwbGljYXRpb24gZG9jdW1lbnRzXG4gICdfcmVwbGljYXRpb25faWQnLFxuICAnX3JlcGxpY2F0aW9uX3N0YXRlJyxcbiAgJ19yZXBsaWNhdGlvbl9zdGF0ZV90aW1lJyxcbiAgJ19yZXBsaWNhdGlvbl9zdGF0ZV9yZWFzb24nLFxuICAnX3JlcGxpY2F0aW9uX3N0YXRzJyxcbiAgLy8gU3BlY2lmaWMgdG8gQ291Y2hiYXNlIFN5bmMgR2F0ZXdheVxuICAnX3JlbW92ZWQnXG5dKTtcblxuLy8gTGlzdCBvZiByZXNlcnZlZCB3b3JkcyB0aGF0IHNob3VsZCBlbmQgdXAgdGhlIGRvY3VtZW50XG52YXIgZGF0YVdvcmRzID0gdG9PYmplY3QoW1xuICAnX2F0dGFjaG1lbnRzJyxcbiAgLy9yZXBsaWNhdGlvbiBkb2N1bWVudHNcbiAgJ19yZXBsaWNhdGlvbl9pZCcsXG4gICdfcmVwbGljYXRpb25fc3RhdGUnLFxuICAnX3JlcGxpY2F0aW9uX3N0YXRlX3RpbWUnLFxuICAnX3JlcGxpY2F0aW9uX3N0YXRlX3JlYXNvbicsXG4gICdfcmVwbGljYXRpb25fc3RhdHMnXG5dKTtcblxuZnVuY3Rpb24gcGFyc2VSZXZpc2lvbkluZm8ocmV2JCQxKSB7XG4gIGlmICghL15cXGQrLS8udGVzdChyZXYkJDEpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yKElOVkFMSURfUkVWKTtcbiAgfVxuICB2YXIgaWR4ID0gcmV2JCQxLmluZGV4T2YoJy0nKTtcbiAgdmFyIGxlZnQgPSByZXYkJDEuc3Vic3RyaW5nKDAsIGlkeCk7XG4gIHZhciByaWdodCA9IHJldiQkMS5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gIHJldHVybiB7XG4gICAgcHJlZml4OiBwYXJzZUludChsZWZ0LCAxMCksXG4gICAgaWQ6IHJpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VSZXZUcmVlRnJvbVJldmlzaW9ucyhyZXZpc2lvbnMsIG9wdHMpIHtcbiAgdmFyIHBvcyA9IHJldmlzaW9ucy5zdGFydCAtIHJldmlzaW9ucy5pZHMubGVuZ3RoICsgMTtcblxuICB2YXIgcmV2aXNpb25JZHMgPSByZXZpc2lvbnMuaWRzO1xuICB2YXIgaWRzID0gW3JldmlzaW9uSWRzWzBdLCBvcHRzLCBbXV07XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHJldmlzaW9uSWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWRzID0gW3JldmlzaW9uSWRzW2ldLCB7c3RhdHVzOiAnbWlzc2luZyd9LCBbaWRzXV07XG4gIH1cblxuICByZXR1cm4gW3tcbiAgICBwb3M6IHBvcyxcbiAgICBpZHM6IGlkc1xuICB9XTtcbn1cblxuLy8gUHJlcHJvY2VzcyBkb2N1bWVudHMsIHBhcnNlIHRoZWlyIHJldmlzaW9ucywgYXNzaWduIGFuIGlkIGFuZCBhXG4vLyByZXZpc2lvbiBmb3IgbmV3IHdyaXRlcyB0aGF0IGFyZSBtaXNzaW5nIHRoZW0sIGV0Y1xuZnVuY3Rpb24gcGFyc2VEb2MoZG9jLCBuZXdFZGl0cywgZGJPcHRzKSB7XG4gIGlmICghZGJPcHRzKSB7XG4gICAgZGJPcHRzID0ge1xuICAgICAgZGV0ZXJtaW5pc3RpY19yZXZzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHZhciBuUmV2TnVtO1xuICB2YXIgbmV3UmV2SWQ7XG4gIHZhciByZXZJbmZvO1xuICB2YXIgb3B0cyA9IHtzdGF0dXM6ICdhdmFpbGFibGUnfTtcbiAgaWYgKGRvYy5fZGVsZXRlZCkge1xuICAgIG9wdHMuZGVsZXRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAobmV3RWRpdHMpIHtcbiAgICBpZiAoIWRvYy5faWQpIHtcbiAgICAgIGRvYy5faWQgPSB1dWlkKCk7XG4gICAgfVxuICAgIG5ld1JldklkID0gcmV2KGRvYywgZGJPcHRzLmRldGVybWluaXN0aWNfcmV2cyk7XG4gICAgaWYgKGRvYy5fcmV2KSB7XG4gICAgICByZXZJbmZvID0gcGFyc2VSZXZpc2lvbkluZm8oZG9jLl9yZXYpO1xuICAgICAgaWYgKHJldkluZm8uZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJldkluZm87XG4gICAgICB9XG4gICAgICBkb2MuX3Jldl90cmVlID0gW3tcbiAgICAgICAgcG9zOiByZXZJbmZvLnByZWZpeCxcbiAgICAgICAgaWRzOiBbcmV2SW5mby5pZCwge3N0YXR1czogJ21pc3NpbmcnfSwgW1tuZXdSZXZJZCwgb3B0cywgW11dXV1cbiAgICAgIH1dO1xuICAgICAgblJldk51bSA9IHJldkluZm8ucHJlZml4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jLl9yZXZfdHJlZSA9IFt7XG4gICAgICAgIHBvczogMSxcbiAgICAgICAgaWRzIDogW25ld1JldklkLCBvcHRzLCBbXV1cbiAgICAgIH1dO1xuICAgICAgblJldk51bSA9IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkb2MuX3JldmlzaW9ucykge1xuICAgICAgZG9jLl9yZXZfdHJlZSA9IG1ha2VSZXZUcmVlRnJvbVJldmlzaW9ucyhkb2MuX3JldmlzaW9ucywgb3B0cyk7XG4gICAgICBuUmV2TnVtID0gZG9jLl9yZXZpc2lvbnMuc3RhcnQ7XG4gICAgICBuZXdSZXZJZCA9IGRvYy5fcmV2aXNpb25zLmlkc1swXTtcbiAgICB9XG4gICAgaWYgKCFkb2MuX3Jldl90cmVlKSB7XG4gICAgICByZXZJbmZvID0gcGFyc2VSZXZpc2lvbkluZm8oZG9jLl9yZXYpO1xuICAgICAgaWYgKHJldkluZm8uZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJldkluZm87XG4gICAgICB9XG4gICAgICBuUmV2TnVtID0gcmV2SW5mby5wcmVmaXg7XG4gICAgICBuZXdSZXZJZCA9IHJldkluZm8uaWQ7XG4gICAgICBkb2MuX3Jldl90cmVlID0gW3tcbiAgICAgICAgcG9zOiBuUmV2TnVtLFxuICAgICAgICBpZHM6IFtuZXdSZXZJZCwgb3B0cywgW11dXG4gICAgICB9XTtcbiAgICB9XG4gIH1cblxuICBpbnZhbGlkSWRFcnJvcihkb2MuX2lkKTtcblxuICBkb2MuX3JldiA9IG5SZXZOdW0gKyAnLScgKyBuZXdSZXZJZDtcblxuICB2YXIgcmVzdWx0ID0ge21ldGFkYXRhIDoge30sIGRhdGEgOiB7fX07XG4gIGZvciAodmFyIGtleSBpbiBkb2MpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZG9jLCBrZXkpKSB7XG4gICAgICB2YXIgc3BlY2lhbEtleSA9IGtleVswXSA9PT0gJ18nO1xuICAgICAgaWYgKHNwZWNpYWxLZXkgJiYgIXJlc2VydmVkV29yZHNba2V5XSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBjcmVhdGVFcnJvcihET0NfVkFMSURBVElPTiwga2V5KTtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IERPQ19WQUxJREFUSU9OLm1lc3NhZ2UgKyAnOiAnICsga2V5O1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZWxzZSBpZiAoc3BlY2lhbEtleSAmJiAhZGF0YVdvcmRzW2tleV0pIHtcbiAgICAgICAgcmVzdWx0Lm1ldGFkYXRhW2tleS5zbGljZSgxKV0gPSBkb2Nba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5kYXRhW2tleV0gPSBkb2Nba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VCYXNlNjQoZGF0YSkge1xuICB0cnkge1xuICAgIHJldHVybiBhdG9iKGRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGVyciA9IGNyZWF0ZUVycm9yKEJBRF9BUkcsXG4gICAgICAnQXR0YWNobWVudCBpcyBub3QgYSB2YWxpZCBiYXNlNjQgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtlcnJvcjogZXJyfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzU3RyaW5nKGF0dCwgYmxvYlR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhc0JpbmFyeSA9IHBhcnNlQmFzZTY0KGF0dC5kYXRhKTtcbiAgaWYgKGFzQmluYXJ5LmVycm9yKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGFzQmluYXJ5LmVycm9yKTtcbiAgfVxuXG4gIGF0dC5sZW5ndGggPSBhc0JpbmFyeS5sZW5ndGg7XG4gIGlmIChibG9iVHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgYXR0LmRhdGEgPSBiaW5hcnlTdHJpbmdUb0Jsb2JPckJ1ZmZlcihhc0JpbmFyeSwgYXR0LmNvbnRlbnRfdHlwZSk7XG4gIH0gZWxzZSBpZiAoYmxvYlR5cGUgPT09ICdiYXNlNjQnKSB7XG4gICAgYXR0LmRhdGEgPSBidG9hKGFzQmluYXJ5KTtcbiAgfSBlbHNlIHsgLy8gYmluYXJ5XG4gICAgYXR0LmRhdGEgPSBhc0JpbmFyeTtcbiAgfVxuICBiaW5hcnlNZDUoYXNCaW5hcnksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBhdHQuZGlnZXN0ID0gJ21kNS0nICsgcmVzdWx0O1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzQmxvYihhdHQsIGJsb2JUeXBlLCBjYWxsYmFjaykge1xuICBiaW5hcnlNZDUoYXR0LmRhdGEsIGZ1bmN0aW9uIChtZDUpIHtcbiAgICBhdHQuZGlnZXN0ID0gJ21kNS0nICsgbWQ1O1xuICAgIC8vIHNpemUgaXMgZm9yIGJsb2JzIChicm93c2VyKSwgbGVuZ3RoIGlzIGZvciBidWZmZXJzIChub2RlKVxuICAgIGF0dC5sZW5ndGggPSBhdHQuZGF0YS5zaXplIHx8IGF0dC5kYXRhLmxlbmd0aCB8fCAwO1xuICAgIGlmIChibG9iVHlwZSA9PT0gJ2JpbmFyeScpIHtcbiAgICAgIGJsb2JPckJ1ZmZlclRvQmluYXJ5U3RyaW5nKGF0dC5kYXRhLCBmdW5jdGlvbiAoYmluU3RyaW5nKSB7XG4gICAgICAgIGF0dC5kYXRhID0gYmluU3RyaW5nO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChibG9iVHlwZSA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIGJsb2JPckJ1ZmZlclRvQmFzZTY0KGF0dC5kYXRhLCBmdW5jdGlvbiAoYjY0KSB7XG4gICAgICAgIGF0dC5kYXRhID0gYjY0O1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc0F0dGFjaG1lbnQoYXR0LCBibG9iVHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKGF0dC5zdHViKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhdHQuZGF0YSA9PT0gJ3N0cmluZycpIHsgLy8gaW5wdXQgaXMgYSBiYXNlNjQgc3RyaW5nXG4gICAgcHJlcHJvY2Vzc1N0cmluZyhhdHQsIGJsb2JUeXBlLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7IC8vIGlucHV0IGlzIGEgYmxvYlxuICAgIHByZXByb2Nlc3NCbG9iKGF0dCwgYmxvYlR5cGUsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzQXR0YWNobWVudHMoZG9jSW5mb3MsIGJsb2JUeXBlLCBjYWxsYmFjaykge1xuXG4gIGlmICghZG9jSW5mb3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICB2YXIgZG9jdiA9IDA7XG4gIHZhciBvdmVyYWxsRXJyO1xuXG4gIGRvY0luZm9zLmZvckVhY2goZnVuY3Rpb24gKGRvY0luZm8pIHtcbiAgICB2YXIgYXR0YWNobWVudHMgPSBkb2NJbmZvLmRhdGEgJiYgZG9jSW5mby5kYXRhLl9hdHRhY2htZW50cyA/XG4gICAgICBPYmplY3Qua2V5cyhkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzKSA6IFtdO1xuICAgIHZhciByZWN2ID0gMDtcblxuICAgIGlmICghYXR0YWNobWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NlZEF0dGFjaG1lbnQoZXJyKSB7XG4gICAgICBvdmVyYWxsRXJyID0gZXJyO1xuICAgICAgcmVjdisrO1xuICAgICAgaWYgKHJlY3YgPT09IGF0dGFjaG1lbnRzLmxlbmd0aCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIGRvY0luZm8uZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgIGlmIChkb2NJbmZvLmRhdGEuX2F0dGFjaG1lbnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcHJlcHJvY2Vzc0F0dGFjaG1lbnQoZG9jSW5mby5kYXRhLl9hdHRhY2htZW50c1trZXldLFxuICAgICAgICAgIGJsb2JUeXBlLCBwcm9jZXNzZWRBdHRhY2htZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgZG9jdisrO1xuICAgIGlmIChkb2NJbmZvcy5sZW5ndGggPT09IGRvY3YpIHtcbiAgICAgIGlmIChvdmVyYWxsRXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKG92ZXJhbGxFcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRG9jKHJldkxpbWl0LCBwcmV2LCBkb2NJbmZvLCByZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgIGksIGNiLCB3cml0ZURvYywgbmV3RWRpdHMpIHtcblxuICBpZiAocmV2RXhpc3RzKHByZXYucmV2X3RyZWUsIGRvY0luZm8ubWV0YWRhdGEucmV2KSAmJiAhbmV3RWRpdHMpIHtcbiAgICByZXN1bHRzW2ldID0gZG9jSW5mbztcbiAgICByZXR1cm4gY2IoKTtcbiAgfVxuXG4gIC8vIHNvbWV0aW1lcyB0aGlzIGlzIHByZS1jYWxjdWxhdGVkLiBoaXN0b3JpY2FsbHkgbm90IGFsd2F5c1xuICB2YXIgcHJldmlvdXNXaW5uaW5nUmV2ID0gcHJldi53aW5uaW5nUmV2IHx8IHdpbm5pbmdSZXYocHJldik7XG4gIHZhciBwcmV2aW91c2x5RGVsZXRlZCA9ICdkZWxldGVkJyBpbiBwcmV2ID8gcHJldi5kZWxldGVkIDpcbiAgICBpc0RlbGV0ZWQocHJldiwgcHJldmlvdXNXaW5uaW5nUmV2KTtcbiAgdmFyIGRlbGV0ZWQgPSAnZGVsZXRlZCcgaW4gZG9jSW5mby5tZXRhZGF0YSA/IGRvY0luZm8ubWV0YWRhdGEuZGVsZXRlZCA6XG4gICAgaXNEZWxldGVkKGRvY0luZm8ubWV0YWRhdGEpO1xuICB2YXIgaXNSb290ID0gL14xLS8udGVzdChkb2NJbmZvLm1ldGFkYXRhLnJldik7XG5cbiAgaWYgKHByZXZpb3VzbHlEZWxldGVkICYmICFkZWxldGVkICYmIG5ld0VkaXRzICYmIGlzUm9vdCkge1xuICAgIHZhciBuZXdEb2MgPSBkb2NJbmZvLmRhdGE7XG4gICAgbmV3RG9jLl9yZXYgPSBwcmV2aW91c1dpbm5pbmdSZXY7XG4gICAgbmV3RG9jLl9pZCA9IGRvY0luZm8ubWV0YWRhdGEuaWQ7XG4gICAgZG9jSW5mbyA9IHBhcnNlRG9jKG5ld0RvYywgbmV3RWRpdHMpO1xuICB9XG5cbiAgdmFyIG1lcmdlZCA9IG1lcmdlKHByZXYucmV2X3RyZWUsIGRvY0luZm8ubWV0YWRhdGEucmV2X3RyZWVbMF0sIHJldkxpbWl0KTtcblxuICB2YXIgaW5Db25mbGljdCA9IG5ld0VkaXRzICYmICgoXG4gICAgKHByZXZpb3VzbHlEZWxldGVkICYmIGRlbGV0ZWQgJiYgbWVyZ2VkLmNvbmZsaWN0cyAhPT0gJ25ld19sZWFmJykgfHxcbiAgICAoIXByZXZpb3VzbHlEZWxldGVkICYmIG1lcmdlZC5jb25mbGljdHMgIT09ICduZXdfbGVhZicpIHx8XG4gICAgKHByZXZpb3VzbHlEZWxldGVkICYmICFkZWxldGVkICYmIG1lcmdlZC5jb25mbGljdHMgPT09ICduZXdfYnJhbmNoJykpKTtcblxuICBpZiAoaW5Db25mbGljdCkge1xuICAgIHZhciBlcnIgPSBjcmVhdGVFcnJvcihSRVZfQ09ORkxJQ1QpO1xuICAgIHJlc3VsdHNbaV0gPSBlcnI7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH1cblxuICB2YXIgbmV3UmV2ID0gZG9jSW5mby5tZXRhZGF0YS5yZXY7XG4gIGRvY0luZm8ubWV0YWRhdGEucmV2X3RyZWUgPSBtZXJnZWQudHJlZTtcbiAgZG9jSW5mby5zdGVtbWVkUmV2cyA9IG1lcmdlZC5zdGVtbWVkUmV2cyB8fCBbXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByZXYucmV2X21hcCkge1xuICAgIGRvY0luZm8ubWV0YWRhdGEucmV2X21hcCA9IHByZXYucmV2X21hcDsgLy8gdXNlZCBvbmx5IGJ5IGxldmVsZGJcbiAgfVxuXG4gIC8vIHJlY2FsY3VsYXRlXG4gIHZhciB3aW5uaW5nUmV2JCQxID0gd2lubmluZ1Jldihkb2NJbmZvLm1ldGFkYXRhKTtcbiAgdmFyIHdpbm5pbmdSZXZJc0RlbGV0ZWQgPSBpc0RlbGV0ZWQoZG9jSW5mby5tZXRhZGF0YSwgd2lubmluZ1JldiQkMSk7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBhZGRlZC9yZW1vdmVkLFxuICAvLyBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiB0b3RhbF9yb3dzL2RvY19jb3VudFxuICB2YXIgZGVsdGEgPSAocHJldmlvdXNseURlbGV0ZWQgPT09IHdpbm5pbmdSZXZJc0RlbGV0ZWQpID8gMCA6XG4gICAgcHJldmlvdXNseURlbGV0ZWQgPCB3aW5uaW5nUmV2SXNEZWxldGVkID8gLTEgOiAxO1xuXG4gIHZhciBuZXdSZXZJc0RlbGV0ZWQ7XG4gIGlmIChuZXdSZXYgPT09IHdpbm5pbmdSZXYkJDEpIHtcbiAgICAvLyBpZiB0aGUgbmV3IHJldiBpcyB0aGUgc2FtZSBhcyB0aGUgd2lubmluZyByZXYsIHdlIGNhbiByZXVzZSB0aGF0IHZhbHVlXG4gICAgbmV3UmV2SXNEZWxldGVkID0gd2lubmluZ1JldklzRGVsZXRlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGV5J3JlIG5vdCB0aGUgc2FtZSwgdGhlbiB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlXG4gICAgbmV3UmV2SXNEZWxldGVkID0gaXNEZWxldGVkKGRvY0luZm8ubWV0YWRhdGEsIG5ld1Jldik7XG4gIH1cblxuICB3cml0ZURvYyhkb2NJbmZvLCB3aW5uaW5nUmV2JCQxLCB3aW5uaW5nUmV2SXNEZWxldGVkLCBuZXdSZXZJc0RlbGV0ZWQsXG4gICAgdHJ1ZSwgZGVsdGEsIGksIGNiKTtcbn1cblxuZnVuY3Rpb24gcm9vdElzTWlzc2luZyhkb2NJbmZvKSB7XG4gIHJldHVybiBkb2NJbmZvLm1ldGFkYXRhLnJldl90cmVlWzBdLmlkc1sxXS5zdGF0dXMgPT09ICdtaXNzaW5nJztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0RvY3MocmV2TGltaXQsIGRvY0luZm9zLCBhcGksIGZldGNoZWREb2NzLCB0eCwgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgIHdyaXRlRG9jLCBvcHRzLCBvdmVyYWxsQ2FsbGJhY2spIHtcblxuICAvLyBEZWZhdWx0IHRvIDEwMDAgbG9jYWxseVxuICByZXZMaW1pdCA9IHJldkxpbWl0IHx8IDEwMDA7XG5cbiAgZnVuY3Rpb24gaW5zZXJ0RG9jKGRvY0luZm8sIHJlc3VsdHNJZHgsIGNhbGxiYWNrKSB7XG4gICAgLy8gQ2FudCBpbnNlcnQgbmV3IGRlbGV0ZWQgZG9jdW1lbnRzXG4gICAgdmFyIHdpbm5pbmdSZXYkJDEgPSB3aW5uaW5nUmV2KGRvY0luZm8ubWV0YWRhdGEpO1xuICAgIHZhciBkZWxldGVkID0gaXNEZWxldGVkKGRvY0luZm8ubWV0YWRhdGEsIHdpbm5pbmdSZXYkJDEpO1xuICAgIGlmICgnd2FzX2RlbGV0ZScgaW4gb3B0cyAmJiBkZWxldGVkKSB7XG4gICAgICByZXN1bHRzW3Jlc3VsdHNJZHhdID0gY3JlYXRlRXJyb3IoTUlTU0lOR19ET0MsICdkZWxldGVkJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvLyA0NzEyIC0gZGV0ZWN0IHdoZXRoZXIgYSBuZXcgZG9jdW1lbnQgd2FzIGluc2VydGVkIHdpdGggYSBfcmV2XG4gICAgdmFyIGluQ29uZmxpY3QgPSBuZXdFZGl0cyAmJiByb290SXNNaXNzaW5nKGRvY0luZm8pO1xuXG4gICAgaWYgKGluQ29uZmxpY3QpIHtcbiAgICAgIHZhciBlcnIgPSBjcmVhdGVFcnJvcihSRVZfQ09ORkxJQ1QpO1xuICAgICAgcmVzdWx0c1tyZXN1bHRzSWR4XSA9IGVycjtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IGRlbGV0ZWQgPyAwIDogMTtcblxuICAgIHdyaXRlRG9jKGRvY0luZm8sIHdpbm5pbmdSZXYkJDEsIGRlbGV0ZWQsIGRlbGV0ZWQsIGZhbHNlLFxuICAgICAgZGVsdGEsIHJlc3VsdHNJZHgsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBuZXdFZGl0cyA9IG9wdHMubmV3X2VkaXRzO1xuICB2YXIgaWRzVG9Eb2NzID0gbmV3IE1hcCgpO1xuXG4gIHZhciBkb2NzRG9uZSA9IDA7XG4gIHZhciBkb2NzVG9EbyA9IGRvY0luZm9zLmxlbmd0aDtcblxuICBmdW5jdGlvbiBjaGVja0FsbERvY3NEb25lKCkge1xuICAgIGlmICgrK2RvY3NEb25lID09PSBkb2NzVG9EbyAmJiBvdmVyYWxsQ2FsbGJhY2spIHtcbiAgICAgIG92ZXJhbGxDYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIGRvY0luZm9zLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnREb2MsIHJlc3VsdHNJZHgpIHtcblxuICAgIGlmIChjdXJyZW50RG9jLl9pZCAmJiBpc0xvY2FsSWQoY3VycmVudERvYy5faWQpKSB7XG4gICAgICB2YXIgZnVuID0gY3VycmVudERvYy5fZGVsZXRlZCA/ICdfcmVtb3ZlTG9jYWwnIDogJ19wdXRMb2NhbCc7XG4gICAgICBhcGlbZnVuXShjdXJyZW50RG9jLCB7Y3R4OiB0eH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHNJZHhdID0gZXJyIHx8IHJlcztcbiAgICAgICAgY2hlY2tBbGxEb2NzRG9uZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkID0gY3VycmVudERvYy5tZXRhZGF0YS5pZDtcbiAgICBpZiAoaWRzVG9Eb2NzLmhhcyhpZCkpIHtcbiAgICAgIGRvY3NUb0RvLS07IC8vIGR1cGxpY2F0ZVxuICAgICAgaWRzVG9Eb2NzLmdldChpZCkucHVzaChbY3VycmVudERvYywgcmVzdWx0c0lkeF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZHNUb0RvY3Muc2V0KGlkLCBbW2N1cnJlbnREb2MsIHJlc3VsdHNJZHhdXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBpbiB0aGUgY2FzZSBvZiBuZXdfZWRpdHMsIHRoZSB1c2VyIGNhbiBwcm92aWRlIG11bHRpcGxlIGRvY3NcbiAgLy8gd2l0aCB0aGUgc2FtZSBpZC4gdGhlc2UgbmVlZCB0byBiZSBwcm9jZXNzZWQgc2VxdWVudGlhbGx5XG4gIGlkc1RvRG9jcy5mb3JFYWNoKGZ1bmN0aW9uIChkb2NzLCBpZCkge1xuICAgIHZhciBudW1Eb25lID0gMDtcblxuICAgIGZ1bmN0aW9uIGRvY1dyaXR0ZW4oKSB7XG4gICAgICBpZiAoKytudW1Eb25lIDwgZG9jcy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dERvYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tBbGxEb2NzRG9uZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBuZXh0RG9jKCkge1xuICAgICAgdmFyIHZhbHVlID0gZG9jc1tudW1Eb25lXTtcbiAgICAgIHZhciBjdXJyZW50RG9jID0gdmFsdWVbMF07XG4gICAgICB2YXIgcmVzdWx0c0lkeCA9IHZhbHVlWzFdO1xuXG4gICAgICBpZiAoZmV0Y2hlZERvY3MuaGFzKGlkKSkge1xuICAgICAgICB1cGRhdGVEb2MocmV2TGltaXQsIGZldGNoZWREb2NzLmdldChpZCksIGN1cnJlbnREb2MsIHJlc3VsdHMsXG4gICAgICAgICAgcmVzdWx0c0lkeCwgZG9jV3JpdHRlbiwgd3JpdGVEb2MsIG5ld0VkaXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuc3VyZSBzdGVtbWluZyBhcHBsaWVzIHRvIG5ldyB3cml0ZXMgYXMgd2VsbFxuICAgICAgICB2YXIgbWVyZ2VkID0gbWVyZ2UoW10sIGN1cnJlbnREb2MubWV0YWRhdGEucmV2X3RyZWVbMF0sIHJldkxpbWl0KTtcbiAgICAgICAgY3VycmVudERvYy5tZXRhZGF0YS5yZXZfdHJlZSA9IG1lcmdlZC50cmVlO1xuICAgICAgICBjdXJyZW50RG9jLnN0ZW1tZWRSZXZzID0gbWVyZ2VkLnN0ZW1tZWRSZXZzIHx8IFtdO1xuICAgICAgICBpbnNlcnREb2MoY3VycmVudERvYywgcmVzdWx0c0lkeCwgZG9jV3JpdHRlbik7XG4gICAgICB9XG4gICAgfVxuICAgIG5leHREb2MoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFsbERvY3NLZXlzUXVlcnksIHBhcnNlRG9jLCBwcmVwcm9jZXNzQXR0YWNobWVudHMsIHByb2Nlc3NEb2NzLCB1cGRhdGVEb2MgfTtcbiIsImltcG9ydCB2dXZ1emVsYSBmcm9tICd2dXZ1emVsYSc7XG5cbmZ1bmN0aW9uIHNhZmVKc29uUGFyc2Uoc3RyKSB7XG4gIC8vIFRoaXMgdHJ5L2NhdGNoIGd1YXJkcyBhZ2FpbnN0IHN0YWNrIG92ZXJmbG93IGVycm9ycy5cbiAgLy8gSlNPTi5wYXJzZSgpIGlzIGZhc3RlciB0aGFuIHZ1dnV6ZWxhLnBhcnNlKCkgYnV0IHZ1dnV6ZWxhXG4gIC8vIGNhbm5vdCBvdmVyZmxvdy5cbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdnV2dXplbGEucGFyc2Uoc3RyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlSnNvblN0cmluZ2lmeShqc29uKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb24pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdnV2dXplbGEuc3RyaW5naWZ5KGpzb24pO1xuICB9XG59XG5cbmV4cG9ydCB7IHNhZmVKc29uUGFyc2UsIHNhZmVKc29uU3RyaW5naWZ5IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3RyaW5naWZ5L3BhcnNlIGZ1bmN0aW9ucyB0aGF0IGRvbid0IG9wZXJhdGVcbiAqIHJlY3Vyc2l2ZWx5LCBzbyB0aGV5IGF2b2lkIGNhbGwgc3RhY2sgZXhjZWVkZWRcbiAqIGVycm9ycy5cbiAqL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaW5wdXQpIHtcbiAgdmFyIHF1ZXVlID0gW107XG4gIHF1ZXVlLnB1c2goe29iajogaW5wdXR9KTtcblxuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuZXh0LCBvYmosIHByZWZpeCwgdmFsLCBpLCBhcnJheVByZWZpeCwga2V5cywgaywga2V5LCB2YWx1ZSwgb2JqUHJlZml4O1xuICB3aGlsZSAoKG5leHQgPSBxdWV1ZS5wb3AoKSkpIHtcbiAgICBvYmogPSBuZXh0Lm9iajtcbiAgICBwcmVmaXggPSBuZXh0LnByZWZpeCB8fCAnJztcbiAgICB2YWwgPSBuZXh0LnZhbCB8fCAnJztcbiAgICByZXMgKz0gcHJlZml4O1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHJlcyArPSB2YWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmVzICs9IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgIHJlcyArPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHF1ZXVlLnB1c2goe3ZhbDogJ10nfSk7XG4gICAgICBmb3IgKGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlQcmVmaXggPSBpID09PSAwID8gJycgOiAnLCc7XG4gICAgICAgIHF1ZXVlLnB1c2goe29iajogb2JqW2ldLCBwcmVmaXg6IGFycmF5UHJlZml4fSk7XG4gICAgICB9XG4gICAgICBxdWV1ZS5wdXNoKHt2YWw6ICdbJ30pO1xuICAgIH0gZWxzZSB7IC8vIG9iamVjdFxuICAgICAga2V5cyA9IFtdO1xuICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWV1ZS5wdXNoKHt2YWw6ICd9J30pO1xuICAgICAgZm9yIChpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBvYmpQcmVmaXggPSAoaSA+IDAgPyAnLCcgOiAnJyk7XG4gICAgICAgIG9ialByZWZpeCArPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzonO1xuICAgICAgICBxdWV1ZS5wdXNoKHtvYmo6IHZhbHVlLCBwcmVmaXg6IG9ialByZWZpeH0pO1xuICAgICAgfVxuICAgICAgcXVldWUucHVzaCh7dmFsOiAneyd9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB0aGUgcGFyc2UgZnVuY3Rpb24uXG4vLyBUaGlzIHBvcCBmdW5jdGlvbiBpcyBiYXNpY2FsbHkgY29waWVkIGZyb21cbi8vIHBvdWNoQ29sbGF0ZS5wYXJzZUluZGV4YWJsZVN0cmluZ1xuZnVuY3Rpb24gcG9wKG9iaiwgc3RhY2ssIG1ldGFTdGFjaykge1xuICB2YXIgbGFzdE1ldGFFbGVtZW50ID0gbWV0YVN0YWNrW21ldGFTdGFjay5sZW5ndGggLSAxXTtcbiAgaWYgKG9iaiA9PT0gbGFzdE1ldGFFbGVtZW50LmVsZW1lbnQpIHtcbiAgICAvLyBwb3BwaW5nIGEgbWV0YS1lbGVtZW50LCBlLmcuIGFuIG9iamVjdCB3aG9zZSB2YWx1ZSBpcyBhbm90aGVyIG9iamVjdFxuICAgIG1ldGFTdGFjay5wb3AoKTtcbiAgICBsYXN0TWV0YUVsZW1lbnQgPSBtZXRhU3RhY2tbbWV0YVN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIHZhciBlbGVtZW50ID0gbGFzdE1ldGFFbGVtZW50LmVsZW1lbnQ7XG4gIHZhciBsYXN0RWxlbWVudEluZGV4ID0gbGFzdE1ldGFFbGVtZW50LmluZGV4O1xuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGVsZW1lbnQucHVzaChvYmopO1xuICB9IGVsc2UgaWYgKGxhc3RFbGVtZW50SW5kZXggPT09IHN0YWNrLmxlbmd0aCAtIDIpIHsgLy8gb2JqIHdpdGgga2V5K3ZhbHVlXG4gICAgdmFyIGtleSA9IHN0YWNrLnBvcCgpO1xuICAgIGVsZW1lbnRba2V5XSA9IG9iajtcbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wdXNoKG9iaik7IC8vIG9iaiB3aXRoIGtleSBvbmx5XG4gIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBtZXRhU3RhY2sgPSBbXTsgLy8gc3RhY2sgZm9yIGFycmF5cyBhbmQgb2JqZWN0c1xuICB2YXIgaSA9IDA7XG4gIHZhciBjb2xsYXRpb25JbmRleCxwYXJzZWROdW0sbnVtQ2hhcjtcbiAgdmFyIHBhcnNlZFN0cmluZyxsYXN0Q2gsbnVtQ29uc2VjdXRpdmVTbGFzaGVzLGNoO1xuICB2YXIgYXJyYXlFbGVtZW50LCBvYmpFbGVtZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbGxhdGlvbkluZGV4ID0gc3RyW2krK107XG4gICAgaWYgKGNvbGxhdGlvbkluZGV4ID09PSAnfScgfHxcbiAgICAgICAgY29sbGF0aW9uSW5kZXggPT09ICddJyB8fFxuICAgICAgICB0eXBlb2YgY29sbGF0aW9uSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcChzdGFjay5wb3AoKSwgc3RhY2ssIG1ldGFTdGFjayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKGNvbGxhdGlvbkluZGV4KSB7XG4gICAgICBjYXNlICcgJzpcbiAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICBjYXNlICdcXG4nOlxuICAgICAgY2FzZSAnOic6XG4gICAgICBjYXNlICcsJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICduJzpcbiAgICAgICAgaSArPSAzOyAvLyAndWxsJ1xuICAgICAgICBwb3AobnVsbCwgc3RhY2ssIG1ldGFTdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndCc6XG4gICAgICAgIGkgKz0gMzsgLy8gJ3J1ZSdcbiAgICAgICAgcG9wKHRydWUsIHN0YWNrLCBtZXRhU3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2YnOlxuICAgICAgICBpICs9IDQ7IC8vICdhbHNlJ1xuICAgICAgICBwb3AoZmFsc2UsIHN0YWNrLCBtZXRhU3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOlxuICAgICAgY2FzZSAnMSc6XG4gICAgICBjYXNlICcyJzpcbiAgICAgIGNhc2UgJzMnOlxuICAgICAgY2FzZSAnNCc6XG4gICAgICBjYXNlICc1JzpcbiAgICAgIGNhc2UgJzYnOlxuICAgICAgY2FzZSAnNyc6XG4gICAgICBjYXNlICc4JzpcbiAgICAgIGNhc2UgJzknOlxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgIHBhcnNlZE51bSA9ICcnO1xuICAgICAgICBpLS07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgbnVtQ2hhciA9IHN0cltpKytdO1xuICAgICAgICAgIGlmICgvW1xcZFxcLlxcLWVcXCtdLy50ZXN0KG51bUNoYXIpKSB7XG4gICAgICAgICAgICBwYXJzZWROdW0gKz0gbnVtQ2hhcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcChwYXJzZUZsb2F0KHBhcnNlZE51bSksIHN0YWNrLCBtZXRhU3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcGFyc2VkU3RyaW5nID0gJyc7XG4gICAgICAgIGxhc3RDaCA9IHZvaWQgMDtcbiAgICAgICAgbnVtQ29uc2VjdXRpdmVTbGFzaGVzID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjaCA9IHN0cltpKytdO1xuICAgICAgICAgIGlmIChjaCAhPT0gJ1wiJyB8fCAobGFzdENoID09PSAnXFxcXCcgJiZcbiAgICAgICAgICAgICAgbnVtQ29uc2VjdXRpdmVTbGFzaGVzICUgMiA9PT0gMSkpIHtcbiAgICAgICAgICAgIHBhcnNlZFN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIGxhc3RDaCA9IGNoO1xuICAgICAgICAgICAgaWYgKGxhc3RDaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIG51bUNvbnNlY3V0aXZlU2xhc2hlcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbnVtQ29uc2VjdXRpdmVTbGFzaGVzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcChKU09OLnBhcnNlKCdcIicgKyBwYXJzZWRTdHJpbmcgKyAnXCInKSwgc3RhY2ssIG1ldGFTdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIGFycmF5RWxlbWVudCA9IHsgZWxlbWVudDogW10sIGluZGV4OiBzdGFjay5sZW5ndGggfTtcbiAgICAgICAgc3RhY2sucHVzaChhcnJheUVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAgIG1ldGFTdGFjay5wdXNoKGFycmF5RWxlbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneyc6XG4gICAgICAgIG9iakVsZW1lbnQgPSB7IGVsZW1lbnQ6IHt9LCBpbmRleDogc3RhY2subGVuZ3RoIH07XG4gICAgICAgIHN0YWNrLnB1c2gob2JqRWxlbWVudC5lbGVtZW50KTtcbiAgICAgICAgbWV0YVN0YWNrLnB1c2gob2JqRWxlbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICd1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgaW5wdXQ6ICcgKyBjb2xsYXRpb25JbmRleCk7XG4gICAgfVxuICB9XG59O1xuIl19